

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>API Reference &mdash; dask-ml 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/style.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/explore.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/nbsphinx.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/javascript" src="../_static/js/custom.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="dask_ml.model_selection.train_test_split" href="generated/dask_ml.model_selection.train_test_split.html" />
    <link rel="prev" title="Clustering" href="../clustering.html" />
  <link rel="shortcut icon" href="../_static/images/favicon.ico"/>
  
  <meta name="Description" content="API Reference">
  <meta property="og:description" content="API Reference">
  <meta name="twitter:description" content="API Reference" />
  <meta property="og:title" content="dask-ml 0.1 documentation - API Reference">
  <meta property="og:image" content="https://github.com/dask.png">
  <meta property="og:image:secure_url" content="https://github.com/dask.png" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:image:width" content="380" />
  <meta property="og:image:height" content="380" />
  <meta property="og:url" content="modules/api.html">
  <meta property="og:site_name" content="dask-ml 0.1 documentation">

  <meta name="twitter:site" content="https://dask.org" />
  <meta name="twitter:creator" content="@dask_dev" />
  <meta name="twitter:card" content="summary">
  <meta name="twitter:image" content="https://github.com/dask.png" />
  <meta name="twitter:image:alt" content="dask-ml 0.1 documentation">
  

</head>

<body class="wy-body-for-nav">

  
    <nav id="explore-links">
        <a href="https://docs.dask.org/">
        <img class="caption" src="../_static/images/dask-horizontal-white.svg"/>
        </a>

        <ul>
        <li>
            <a>Get Started</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/install.html"> Install </a></li>
            <li><a href="https://examples.dask.org"> Examples </a></li>
            <li><a href="https://github.com/dask/dask-tutorial"> Tutorial </a></li>
            <li><a href="https://docs.dask.org/en/latest/why.html"> Why Dask? </a></li>
            <li><a href="https://stories.dask.org/en/latest"> Use Cases </a></li>
            <li><a href="https://www.youtube.com/watch?v=RA_2qdipVng&list=PLRtz5iA93T4PQvWuoMnIyEIz1fXiJ5Pri"> Talks </a></li>
            <li><a href="https://mybinder.org/v2/gh/dask/dask-examples/master?urlpath=lab"> Try Online </a></li>
            <li><a href="https://dask.org/slides"> Slides </a></li>
            </ul>
        </li>

        <li>
            <a href="">Algorithms</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/array.html">Arrays</a></li>
            <li><a href="https://docs.dask.org/en/latest/dataframe.html">Dataframes</a></li>
            <li><a href="https://docs.dask.org/en/latest/bag.html">Bags</a></li>
            <li><a href="https://docs.dask.org/en/latest/delayed.html">Delayed (custom)</a></li>
            <li><a href="https://docs.dask.org/en/latest/futures.html">Futures (real-time)</a></li>
            <li><a href="http://ml.dask.org">Machine Learning</a></li>
            <li><a href="https://xarray.pydata.org/en/latest/">XArray</a></li>
            </ul>
        </li>

        <li>
            <a href="https://docs.dask.org/en/latest/setup.html">Setup</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/setup/single-machine.html"> Local </a></li>
            <li><a href="https://docs.dask.org/en/latest/setup/cloud.html"> Cloud </a></li>
            <li><a href="https://docs.dask.org/en/latest/setup/hpc.html"> HPC </a></li>
            <li><a href="https://kubernetes.dask.org/en/latest/"> Kubernetes </a></li>
            <li><a href="https://yarn.dask.org/en/latest/"> Hadoop / Yarn </a></li>
            </ul>
        </li>

        <li>
            <a>Community</a>
            <ul>
            <li><a href="http://docs.dask.org/en/latest/support.html">Ask for Help</a></li>
            <li><a href="https://github.com/dask">Github</a></li>
            <li><a href="https://stackoverflow.com/questions/tagged/dask">Stack Overflow</a></li>
            <li><a href="https://twitter.com/dask_dev">Twitter</a></li>
            <li><a href="https://blog.dask.org/"> Developer Blog </a></li>
            <li><a href="https://youtube.com/c/dask-dev"> YouTube Channel </a></li>
            </ul>
        </li>
        </ul>

    </nav>
  
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> dask-ml
          

          
          </a>

          
            
            
              <div class="version">
                0.1.dev1+g80eb0d8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Use</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../preprocessing.html">Preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cross_validation.html">Cross Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hyper-parameter-search.html">Hyper Parameter Search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../compose.html">Pipelines and Composite Estimators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glm.html">Generalized Linear Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../naive-bayes.html">Naive Bayes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../meta-estimators.html">Parallel Meta-estimators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../incremental.html">Incremental Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../clustering.html">Clustering</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-dask_ml.model_selection"><code class="docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code>: Model Selection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.model_selection.train_test_split.html">dask_ml.model_selection.train_test_split</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.model_selection.ShuffleSplit.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code>.ShuffleSplit</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.model_selection.KFold.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code>.KFold</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.model_selection.GridSearchCV.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code>.GridSearchCV</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.model_selection.RandomizedSearchCV.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code>.RandomizedSearchCV</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.model_selection.IncrementalSearchCV.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code>.IncrementalSearchCV</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.model_selection.HyperbandSearchCV.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code>.HyperbandSearchCV</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.model_selection.SuccessiveHalvingSearchCV.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code>.SuccessiveHalvingSearchCV</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.model_selection.InverseDecaySearchCV.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code>.InverseDecaySearchCV</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-dask_ml.ensemble"><code class="docutils literal notranslate"><span class="pre">dask_ml.ensemble</span></code>: Ensemble Methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.ensemble.BlockwiseVotingClassifier.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.ensemble</span></code>.BlockwiseVotingClassifier</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.ensemble.BlockwiseVotingRegressor.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.ensemble</span></code>.BlockwiseVotingRegressor</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-dask_ml.linear_model"><code class="docutils literal notranslate"><span class="pre">dask_ml.linear_model</span></code>: Generalized Linear Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.linear_model.LinearRegression.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.linear_model</span></code>.LinearRegression</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.linear_model.LogisticRegression.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.linear_model</span></code>.LogisticRegression</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.linear_model.PoissonRegression.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.linear_model</span></code>.PoissonRegression</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-dask_ml.naive_bayes"><code class="docutils literal notranslate"><span class="pre">dask_ml.naive_bayes</span></code>: Naive Bayes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.naive_bayes.GaussianNB.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.naive_bayes</span></code>.GaussianNB</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dask-ml-wrappers-meta-estimators"><code class="docutils literal notranslate"><span class="pre">dask_ml.wrappers</span></code>: Meta-Estimators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.wrappers.ParallelPostFit.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.wrappers</span></code>.ParallelPostFit</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.wrappers.Incremental.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.wrappers</span></code>.Incremental</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-dask_ml.cluster"><code class="docutils literal notranslate"><span class="pre">dask_ml.cluster</span></code>: Clustering</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.cluster.KMeans.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.cluster</span></code>.KMeans</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.cluster.SpectralClustering.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.cluster</span></code>.SpectralClustering</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-dask_ml.decomposition"><code class="docutils literal notranslate"><span class="pre">dask_ml.decomposition</span></code>: Matrix Decomposition</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.decomposition.IncrementalPCA.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.decomposition</span></code>.IncrementalPCA</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.decomposition.PCA.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.decomposition</span></code>.PCA</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.decomposition.TruncatedSVD.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.decomposition</span></code>.TruncatedSVD</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-dask_ml.preprocessing"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>: Preprocessing Data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.StandardScaler</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.RobustScaler</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.MinMaxScaler</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.QuantileTransformer.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.QuantileTransformer</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.StandardScaler</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.Categorizer.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.Categorizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.DummyEncoder.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.DummyEncoder</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.OrdinalEncoder.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.OrdinalEncoder</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.LabelEncoder.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.LabelEncoder</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.PolynomialFeatures.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.PolynomialFeatures</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.preprocessing.BlockTransformer.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code>.BlockTransformer</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dask-ml-feature-extraction-text-feature-extraction"><code class="docutils literal notranslate"><span class="pre">dask_ml.feature_extraction.text</span></code>: Feature extraction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.feature_extraction.text.CountVectorizer.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.feature_extraction.text</span></code>.CountVectorizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.feature_extraction.text.HashingVectorizer.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.feature_extraction.text</span></code>.HashingVectorizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.feature_extraction.text.FeatureHasher.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.feature_extraction.text</span></code>.FeatureHasher</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dask-ml-compose-composite-estimators"><code class="docutils literal notranslate"><span class="pre">dask_ml.compose</span></code>: Composite Estimators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.compose.ColumnTransformer.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.compose</span></code>.ColumnTransformer</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.compose.make_column_transformer.html">dask_ml.compose.make_column_transformer</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-dask_ml.impute"><code class="docutils literal notranslate"><span class="pre">dask_ml.impute</span></code>: Imputing Missing Data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.impute.SimpleImputer.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.impute</span></code>.SimpleImputer</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dask-ml-metrics-metrics"><code class="docutils literal notranslate"><span class="pre">dask_ml.metrics</span></code>: Metrics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#regression-metrics">Regression Metrics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="generated/dask_ml.metrics.mean_absolute_error.html">dask_ml.metrics.mean_absolute_error</a></li>
<li class="toctree-l4"><a class="reference internal" href="generated/dask_ml.metrics.mean_squared_error.html">dask_ml.metrics.mean_squared_error</a></li>
<li class="toctree-l4"><a class="reference internal" href="generated/dask_ml.metrics.mean_squared_log_error.html">dask_ml.metrics.mean_squared_log_error</a></li>
<li class="toctree-l4"><a class="reference internal" href="generated/dask_ml.metrics.r2_score.html">dask_ml.metrics.r2_score</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#classification-metrics">Classification Metrics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="generated/dask_ml.metrics.accuracy_score.html">dask_ml.metrics.accuracy_score</a></li>
<li class="toctree-l4"><a class="reference internal" href="generated/dask_ml.metrics.log_loss.html">dask_ml.metrics.log_loss</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-dask_ml.xgboost"><code class="docutils literal notranslate"><span class="pre">dask_ml.xgboost</span></code>: XGBoost</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.xgboost.XGBClassifier.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.xgboost</span></code>.XGBClassifier</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.xgboost.XGBRegressor.html"><code class="docutils literal notranslate"><span class="pre">dask_ml.xgboost</span></code>.XGBRegressor</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.xgboost.train.html">dask_ml.xgboost.train</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.xgboost.predict.html">dask_ml.xgboost.predict</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dask-ml-datasets-datasets"><code class="docutils literal notranslate"><span class="pre">dask_ml.datasets</span></code>: Datasets</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.datasets.make_counts.html">dask_ml.datasets.make_counts</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.datasets.make_blobs.html">dask_ml.datasets.make_blobs</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.datasets.make_regression.html">dask_ml.datasets.make_regression</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.datasets.make_classification.html">dask_ml.datasets.make_classification</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/dask_ml.datasets.make_classification_df.html">dask_ml.datasets.make_classification_df</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Integration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../joblib.html">Scikit-Learn &amp; Joblib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xgboost.html">XGBoost &amp; LightGBM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pytorch.html">PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../keras.html">Keras and Tensorflow</a></li>
</ul>
<p class="caption"><span class="caption-text">Develop</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../roadmap.html">Dask-ML Roadmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">History</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">dask-ml</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>API Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/modules/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api-reference">
<span id="api"></span><h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<p>This page lists all of the estimators and top-level functions in <code class="docutils literal notranslate"><span class="pre">dask_ml</span></code>.
Unless otherwise noted, the estimators implemented in <code class="docutils literal notranslate"><span class="pre">dask-ml</span></code> are
appropriate for parallel and distributed training.</p>
<div class="section" id="module-dask_ml.model_selection">
<span id="dask-ml-model-selection-model-selection"></span><h2><a class="reference internal" href="#module-dask_ml.model_selection" title="dask_ml.model_selection"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.model_selection</span></code></a>: Model Selection<a class="headerlink" href="#module-dask_ml.model_selection" title="Permalink to this headline">¶</a></h2>
<p>Utilities for hyperparameter optimization.</p>
<p>These estimators will operate in parallel. Their scalability depends
on the underlying estimators being used.</p>
<p>Dask-ML has a few cross validation utilities.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.model_selection.train_test_split.html#dask_ml.model_selection.train_test_split" title="dask_ml.model_selection.train_test_split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_selection.train_test_split</span></code></a>(*arrays[,&nbsp;…])</td>
<td>Split arrays into random train and test matrices.</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="generated/dask_ml.model_selection.train_test_split.html#dask_ml.model_selection.train_test_split" title="dask_ml.model_selection.train_test_split"><code class="xref py py-func docutils literal notranslate"><span class="pre">model_selection.train_test_split()</span></code></a> is a simple helper that
uses <a class="reference internal" href="generated/dask_ml.model_selection.ShuffleSplit.html#dask_ml.model_selection.ShuffleSplit" title="dask_ml.model_selection.ShuffleSplit"><code class="xref py py-class docutils literal notranslate"><span class="pre">model_selection.ShuffleSplit</span></code></a> internally.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.model_selection.ShuffleSplit.html#dask_ml.model_selection.ShuffleSplit" title="dask_ml.model_selection.ShuffleSplit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_selection.ShuffleSplit</span></code></a>([n_splits,&nbsp;…])</td>
<td>Random permutation cross-validator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.model_selection.KFold.html#dask_ml.model_selection.KFold" title="dask_ml.model_selection.KFold"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_selection.KFold</span></code></a>([n_splits,&nbsp;shuffle,&nbsp;…])</td>
<td>K-Folds cross-validator</td>
</tr>
</tbody>
</table>
<p>Dask-ML provides drop-in replacements for grid and randomized search.
These are appropriate for datasets where the CV splits fit in memory.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.model_selection.GridSearchCV.html#dask_ml.model_selection.GridSearchCV" title="dask_ml.model_selection.GridSearchCV"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_selection.GridSearchCV</span></code></a>(estimator,&nbsp;…)</td>
<td>Exhaustive search over specified parameter values for an estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.model_selection.RandomizedSearchCV.html#dask_ml.model_selection.RandomizedSearchCV" title="dask_ml.model_selection.RandomizedSearchCV"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_selection.RandomizedSearchCV</span></code></a>(…[,&nbsp;…])</td>
<td>Randomized search on hyper parameters.</td>
</tr>
</tbody>
</table>
<p>For hyperparameter optimization on larger-than-memory datasets, Dask-ML
provides the following:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.model_selection.IncrementalSearchCV.html#dask_ml.model_selection.IncrementalSearchCV" title="dask_ml.model_selection.IncrementalSearchCV"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_selection.IncrementalSearchCV</span></code></a>(…[,&nbsp;…])</td>
<td>Incrementally search for hyper-parameters on models that support partial_fit</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.model_selection.HyperbandSearchCV.html#dask_ml.model_selection.HyperbandSearchCV" title="dask_ml.model_selection.HyperbandSearchCV"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_selection.HyperbandSearchCV</span></code></a>(estimator,&nbsp;…)</td>
<td>Find the best parameters for a particular model with an adaptive cross-validation algorithm.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.model_selection.SuccessiveHalvingSearchCV.html#dask_ml.model_selection.SuccessiveHalvingSearchCV" title="dask_ml.model_selection.SuccessiveHalvingSearchCV"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_selection.SuccessiveHalvingSearchCV</span></code></a>(…)</td>
<td>Perform the successive halving algorithm <a class="reference internal" href="generated/dask_ml.model_selection.SuccessiveHalvingSearchCV.html#r424ea1a907b1-1" id="id1">[R424ea1a907b1-1]</a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.model_selection.InverseDecaySearchCV.html#dask_ml.model_selection.InverseDecaySearchCV" title="dask_ml.model_selection.InverseDecaySearchCV"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_selection.InverseDecaySearchCV</span></code></a>(…[,&nbsp;…])</td>
<td>Incrementally search for hyper-parameters on models that support partial_fit</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dask_ml.ensemble">
<span id="dask-ml-ensemble-ensemble-methods"></span><h2><a class="reference internal" href="#module-dask_ml.ensemble" title="dask_ml.ensemble"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.ensemble</span></code></a>: Ensemble Methods<a class="headerlink" href="#module-dask_ml.ensemble" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.ensemble.BlockwiseVotingClassifier.html#dask_ml.ensemble.BlockwiseVotingClassifier" title="dask_ml.ensemble.BlockwiseVotingClassifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ensemble.BlockwiseVotingClassifier</span></code></a>(estimator)</td>
<td>Blockwise training and ensemble voting classifier.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.ensemble.BlockwiseVotingRegressor.html#dask_ml.ensemble.BlockwiseVotingRegressor" title="dask_ml.ensemble.BlockwiseVotingRegressor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ensemble.BlockwiseVotingRegressor</span></code></a>(estimator)</td>
<td>Blockwise training and ensemble voting regressor.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dask_ml.linear_model">
<span id="dask-ml-linear-model-generalized-linear-models"></span><h2><a class="reference internal" href="#module-dask_ml.linear_model" title="dask_ml.linear_model"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.linear_model</span></code></a>: Generalized Linear Models<a class="headerlink" href="#module-dask_ml.linear_model" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">dask_ml.linear_model</span></code> module implements linear models for
classification and regression.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.linear_model.LinearRegression.html#dask_ml.linear_model.LinearRegression" title="dask_ml.linear_model.LinearRegression"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linear_model.LinearRegression</span></code></a>([penalty,&nbsp;…])</td>
<td>Esimator for linear regression.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.linear_model.LogisticRegression.html#dask_ml.linear_model.LogisticRegression" title="dask_ml.linear_model.LogisticRegression"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linear_model.LogisticRegression</span></code></a>([penalty,&nbsp;…])</td>
<td>Esimator for logistic regression.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.linear_model.PoissonRegression.html#dask_ml.linear_model.PoissonRegression" title="dask_ml.linear_model.PoissonRegression"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linear_model.PoissonRegression</span></code></a>([penalty,&nbsp;…])</td>
<td>Esimator for poisson regression.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dask_ml.naive_bayes">
<span id="dask-ml-naive-bayes-naive-bayes"></span><h2><a class="reference internal" href="#module-dask_ml.naive_bayes" title="dask_ml.naive_bayes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.naive_bayes</span></code></a>: Naive Bayes<a class="headerlink" href="#module-dask_ml.naive_bayes" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.naive_bayes.GaussianNB.html#dask_ml.naive_bayes.GaussianNB" title="dask_ml.naive_bayes.GaussianNB"><code class="xref py py-obj docutils literal notranslate"><span class="pre">naive_bayes.GaussianNB</span></code></a>([priors,&nbsp;classes])</td>
<td>Fit a naive bayes model with a Gaussian likelihood</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dask-ml-wrappers-meta-estimators">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.wrappers</span></code>: Meta-Estimators<a class="headerlink" href="#dask-ml-wrappers-meta-estimators" title="Permalink to this headline">¶</a></h2>
<p>dask-ml provides some meta-estimators that help use regular
estimators that follow the scikit-learn API.
These meta-estimators make the underlying estimator work well
with Dask Arrays or DataFrames.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.wrappers.ParallelPostFit.html#dask_ml.wrappers.ParallelPostFit" title="dask_ml.wrappers.ParallelPostFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wrappers.ParallelPostFit</span></code></a>([estimator,&nbsp;scoring])</td>
<td>Meta-estimator for parallel predict and transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.wrappers.Incremental.html#dask_ml.wrappers.Incremental" title="dask_ml.wrappers.Incremental"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wrappers.Incremental</span></code></a>([estimator,&nbsp;scoring,&nbsp;…])</td>
<td>Metaestimator for feeding Dask Arrays to an estimator blockwise.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dask_ml.cluster">
<span id="dask-ml-cluster-clustering"></span><h2><a class="reference internal" href="#module-dask_ml.cluster" title="dask_ml.cluster"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.cluster</span></code></a>: Clustering<a class="headerlink" href="#module-dask_ml.cluster" title="Permalink to this headline">¶</a></h2>
<p>Unsupervised Clustering Algorithms</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.cluster.KMeans.html#dask_ml.cluster.KMeans" title="dask_ml.cluster.KMeans"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cluster.KMeans</span></code></a>([n_clusters,&nbsp;init,&nbsp;…])</td>
<td>Scalable KMeans for clustering</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.cluster.SpectralClustering.html#dask_ml.cluster.SpectralClustering" title="dask_ml.cluster.SpectralClustering"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cluster.SpectralClustering</span></code></a>([n_clusters,&nbsp;…])</td>
<td>Apply parallel Spectral Clustering</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dask_ml.decomposition">
<span id="dask-ml-decomposition-matrix-decomposition"></span><h2><a class="reference internal" href="#module-dask_ml.decomposition" title="dask_ml.decomposition"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.decomposition</span></code></a>: Matrix Decomposition<a class="headerlink" href="#module-dask_ml.decomposition" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.decomposition.IncrementalPCA.html#dask_ml.decomposition.IncrementalPCA" title="dask_ml.decomposition.IncrementalPCA"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decomposition.IncrementalPCA</span></code></a>([n_components,&nbsp;…])</td>
<td>Incremental principal components analysis (IPCA).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.decomposition.PCA.html#dask_ml.decomposition.PCA" title="dask_ml.decomposition.PCA"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decomposition.PCA</span></code></a>([n_components,&nbsp;copy,&nbsp;…])</td>
<td>Principal component analysis (PCA)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.decomposition.TruncatedSVD.html#dask_ml.decomposition.TruncatedSVD" title="dask_ml.decomposition.TruncatedSVD"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decomposition.TruncatedSVD</span></code></a>([n_components,&nbsp;…])</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dask_ml.preprocessing">
<span id="dask-ml-preprocessing-preprocessing-data"></span><h2><a class="reference internal" href="#module-dask_ml.preprocessing" title="dask_ml.preprocessing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.preprocessing</span></code></a>: Preprocessing Data<a class="headerlink" href="#module-dask_ml.preprocessing" title="Permalink to this headline">¶</a></h2>
<p>Utilties for Preprocessing data.</p>
<dl class="class">
<dt id="dask_ml.preprocessing.StandardScaler">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">StandardScaler</code><span class="sig-paren">(</span><em>*</em>, <em>copy=True</em>, <em>with_mean=True</em>, <em>with_std=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.StandardScaler" title="Permalink to this definition">¶</a></dt>
<dd><p>Standardize features by removing the mean and scaling to unit variance</p>
<p>The standard score of a sample <cite>x</cite> is calculated as:</p>
<blockquote>
<div>z = (x - u) / s</div></blockquote>
<p>where <cite>u</cite> is the mean of the training samples or zero if <cite>with_mean=False</cite>,
and <cite>s</cite> is the standard deviation of the training samples or one if
<cite>with_std=False</cite>.</p>
<p>Centering and scaling happen independently on each feature by computing
the relevant statistics on the samples in the training set. Mean and
standard deviation are then stored to be used on later data using
<a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler.transform" title="dask_ml.preprocessing.StandardScaler.transform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform()</span></code></a>.</p>
<p>Standardization of a dataset is a common requirement for many
machine learning estimators: they might behave badly if the
individual features do not more or less look like standard normally
distributed data (e.g. Gaussian with 0 mean and unit variance).</p>
<p>For instance many elements used in the objective function of
a learning algorithm (such as the RBF kernel of Support Vector
Machines or the L1 and L2 regularizers of linear models) assume that
all features are centered around 0 and have variance in the same
order. If a feature has a variance that is orders of magnitude larger
that others, it might dominate the objective function and make the
estimator unable to learn from other features correctly as expected.</p>
<p>This scaler can also be applied to sparse CSR or CSC matrices by passing
<cite>with_mean=False</cite> to avoid breaking the sparsity structure of the data.</p>
<p>Read more in the <a class="reference external" href="https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-scaler" title="(in scikit-learn v0.24)"><span class="xref std std-ref">User Guide</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If False, try to avoid a copy and do inplace scaling instead.
This is not guaranteed to always work inplace; e.g. if the data is
not a NumPy array or scipy.sparse CSR matrix, a copy may still be
returned.</p>
</dd>
<dt><strong>with_mean</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, center the data before scaling.
This does not work (and will raise an exception) when attempted on
sparse matrices, because centering them entails building a dense
matrix which in common use cases is likely to be too large to fit in
memory.</p>
</dd>
<dt><strong>with_std</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, scale the data to unit variance (or equivalently,
unit standard deviation).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>scale_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_features,) or None</span></dt>
<dd><p class="first">Per feature relative scaling of the data to achieve zero mean and unit
variance. Generally this is calculated using <cite>np.sqrt(var_)</cite>. If a
variance is zero, we can’t achieve unit variance, and the data is left
as-is, giving a scaling factor of 1. <cite>scale_</cite> is equal to <cite>None</cite>
when <cite>with_std=False</cite>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.17: </span><em>scale_</em></p>
</div>
</dd>
<dt><strong>mean_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_features,) or None</span></dt>
<dd><p class="first last">The mean value for each feature in the training set.
Equal to <code class="docutils literal notranslate"><span class="pre">None</span></code> when <code class="docutils literal notranslate"><span class="pre">with_mean=False</span></code>.</p>
</dd>
<dt><strong>var_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_features,) or None</span></dt>
<dd><p class="first last">The variance for each feature in the training set. Used to compute
<cite>scale_</cite>. Equal to <code class="docutils literal notranslate"><span class="pre">None</span></code> when <code class="docutils literal notranslate"><span class="pre">with_std=False</span></code>.</p>
</dd>
<dt><strong>n_samples_seen_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or ndarray of shape (n_features,)</span></dt>
<dd><p class="first last">The number of samples processed by the estimator for each feature.
If there are no missing samples, the <code class="docutils literal notranslate"><span class="pre">n_samples_seen</span></code> will be an
integer, otherwise it will be an array of dtype int. If
<cite>sample_weights</cite> are used it will be a float (if no missing data)
or an array of dtype float that sums the weights seen so far.
Will be reset on new calls to fit, but increments across
<code class="docutils literal notranslate"><span class="pre">partial_fit</span></code> calls.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></dt>
<dd>Equivalent function without the estimator API.</dd>
<dt><a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html#sklearn.decomposition.PCA" title="(in scikit-learn v0.24)"><code class="xref py py-class docutils literal notranslate"><span class="pre">PCA</span></code></a></dt>
<dd>Further removes the linear correlation across features with ‘whiten=True’.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>NaNs are treated as missing values: disregarded in fit, and maintained in
transform.</p>
<p>We use a biased estimator for the standard deviation, equivalent to
<cite>numpy.std(x, ddof=0)</cite>. Note that the choice of <cite>ddof</cite> is unlikely to
affect model performance.</p>
<p>For a comparison of the different scalers, transformers, and normalizers,
see <a class="reference external" href="https://scikit-learn.org/stable/auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py" title="(in scikit-learn v0.24)"><span class="xref std std-ref">examples/preprocessing/plot_all_scaling.py</span></a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">StandardScaler()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">mean_</span><span class="p">)</span>
<span class="go">[0.5 0.5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">[[-1. -1.]</span>
<span class="go"> [-1. -1.]</span>
<span class="go"> [ 1.  1.]</span>
<span class="go"> [ 1.  1.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]))</span>
<span class="go">[[3. 3.]]</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler.fit" title="dask_ml.preprocessing.StandardScaler.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X,&nbsp;pandas.core.frame.DataFrame,&nbsp;…)</td>
<td>Compute the mean and std to be used for later scaling.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler.fit_transform" title="dask_ml.preprocessing.StandardScaler.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler.get_params" title="dask_ml.preprocessing.StandardScaler.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler.inverse_transform" title="dask_ml.preprocessing.StandardScaler.inverse_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_transform</span></code></a>(X,&nbsp;…)</td>
<td>Scale back the data to the original representation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler.partial_fit" title="dask_ml.preprocessing.StandardScaler.partial_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partial_fit</span></code></a>(X,&nbsp;pandas.core.frame.DataFrame,&nbsp;…)</td>
<td>Online computation of mean and std on X for later scaling.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler.set_params" title="dask_ml.preprocessing.StandardScaler.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler.transform" title="dask_ml.preprocessing.StandardScaler.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X,&nbsp;pandas.core.frame.DataFrame,&nbsp;…)</td>
<td>Perform standardization by centering and scaling</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.StandardScaler.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None</em><span class="sig-paren">)</span> &#x2192; dask_ml.preprocessing.data.StandardScaler<a class="headerlink" href="#dask_ml.preprocessing.StandardScaler.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean and std to be used for later scaling.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The data used to compute the mean and standard deviation
used for later scaling along the features axis.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">Ignored.</p>
</dd>
<dt><strong>sample_weight</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,), default=None</span></dt>
<dd><p class="first">Individual weights for each sample.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.24: </span>parameter <em>sample_weight</em> support to StandardScaler.</p>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Fitted scaler.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.StandardScaler.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.StandardScaler.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to <cite>X</cite> and <cite>y</cite> with optional parameters <cite>fit_params</cite>
and returns a transformed version of <cite>X</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Input samples.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None</span></dt>
<dd><p class="first last">Target values (None for unsupervised transformations).</p>
</dd>
<dt><strong>**fit_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Additional fit parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray array of shape (n_samples, n_features_new)</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.StandardScaler.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.StandardScaler.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.StandardScaler.inverse_transform">
<code class="descname">inverse_transform</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], copy: Optional[bool] = None</em><span class="sig-paren">)</span> &#x2192; Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]<a class="headerlink" href="#dask_ml.preprocessing.StandardScaler.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale back the data to the original representation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The data used to scale along the features axis.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=None</span></dt>
<dd><p class="first last">Copy the input X or not.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_tr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{ndarray, sparse matrix} of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.StandardScaler.partial_fit">
<code class="descname">partial_fit</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.StandardScaler.partial_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Online computation of mean and std on X for later scaling.</p>
<p>All of X is processed as a single batch. This is intended for cases
when <a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler.fit" title="dask_ml.preprocessing.StandardScaler.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> is not feasible due to very large number of
<cite>n_samples</cite> or because X is read from a continuous stream.</p>
<p>The algorithm for incremental mean and std is given in Equation 1.5a,b
in Chan, Tony F., Gene H. Golub, and Randall J. LeVeque. “Algorithms
for computing the sample variance: Analysis and recommendations.”
The American Statistician 37.3 (1983): 242-247:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The data used to compute the mean and standard deviation
used for later scaling along the features axis.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">Ignored.</p>
</dd>
<dt><strong>sample_weight</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,), default=None</span></dt>
<dd><p class="first">Individual weights for each sample.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.24: </span>parameter <em>sample_weight</em> support to StandardScaler.</p>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Fitted scaler.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.StandardScaler.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.StandardScaler.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="(in scikit-learn v0.24)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>). The latter have
parameters of the form <code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s
possible to update each component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>**params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Estimator parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">estimator instance</span></dt>
<dd><p class="first last">Estimator instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.StandardScaler.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None, copy: Optional[bool] = None</em><span class="sig-paren">)</span> &#x2192; Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]<a class="headerlink" href="#dask_ml.preprocessing.StandardScaler.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform standardization by centering and scaling</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The data used to scale along the features axis.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=None</span></dt>
<dd><p class="first last">Copy the input X or not.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_tr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{ndarray, sparse matrix} of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.MinMaxScaler">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">MinMaxScaler</code><span class="sig-paren">(</span><em>feature_range=(0</em>, <em>1)</em>, <em>*</em>, <em>copy=True</em>, <em>clip=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.MinMaxScaler" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform features by scaling each feature to a given range.</p>
<p>This estimator scales and translates each feature individually such
that it is in the given range on the training set, e.g. between
zero and one.</p>
<p>The transformation is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="n">X_scaled</span> <span class="o">=</span> <span class="n">X_std</span> <span class="o">*</span> <span class="p">(</span><span class="nb">max</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span> <span class="o">+</span> <span class="nb">min</span>
</pre></div>
</div>
<p>where min, max = feature_range.</p>
<p>This transformation is often used as an alternative to zero mean,
unit variance scaling.</p>
<p>Read more in the <a class="reference external" href="https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-scaler" title="(in scikit-learn v0.24)"><span class="xref std std-ref">User Guide</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>feature_range</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple (min, max), default=(0, 1)</span></dt>
<dd><p class="first last">Desired range of transformed data.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">Set to False to perform inplace row normalization and avoid a
copy (if the input is already a numpy array).</p>
</dd>
<dt><strong>clip: bool, default=False</strong></dt>
<dd><p class="first">Set to True to clip transformed values of held-out data to
provided <cite>feature range</cite>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.24.</span></p>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>min_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_features,)</span></dt>
<dd><p class="first last">Per feature adjustment for minimum. Equivalent to
<code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">-</span> <span class="pre">X.min(axis=0)</span> <span class="pre">*</span> <span class="pre">self.scale_</span></code></p>
</dd>
<dt><strong>scale_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_features,)</span></dt>
<dd><p class="first">Per feature relative scaling of the data. Equivalent to
<code class="docutils literal notranslate"><span class="pre">(max</span> <span class="pre">-</span> <span class="pre">min)</span> <span class="pre">/</span> <span class="pre">(X.max(axis=0)</span> <span class="pre">-</span> <span class="pre">X.min(axis=0))</span></code></p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.17: </span><em>scale_</em> attribute.</p>
</div>
</dd>
<dt><strong>data_min_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_features,)</span></dt>
<dd><p class="first">Per feature minimum seen in the data</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.17: </span><em>data_min_</em></p>
</div>
</dd>
<dt><strong>data_max_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_features,)</span></dt>
<dd><p class="first">Per feature maximum seen in the data</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.17: </span><em>data_max_</em></p>
</div>
</dd>
<dt><strong>data_range_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_features,)</span></dt>
<dd><p class="first">Per feature range <code class="docutils literal notranslate"><span class="pre">(data_max_</span> <span class="pre">-</span> <span class="pre">data_min_)</span></code> seen in the data</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.17: </span><em>data_range_</em></p>
</div>
</dd>
<dt><strong>n_samples_seen_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of samples processed by the estimator.
It will be reset on new calls to fit, but increments across
<code class="docutils literal notranslate"><span class="pre">partial_fit</span></code> calls.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">minmax_scale</span></code></dt>
<dd>Equivalent function without the estimator API.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>NaNs are treated as missing values: disregarded in fit, and maintained in
transform.</p>
<p>For a comparison of the different scalers, transformers, and normalizers,
see <a class="reference external" href="https://scikit-learn.org/stable/auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py" title="(in scikit-learn v0.24)"><span class="xref std std-ref">examples/preprocessing/plot_all_scaling.py</span></a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">MinMaxScaler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">18</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">MinMaxScaler()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">data_max_</span><span class="p">)</span>
<span class="go">[ 1. 18.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">[[0.   0.  ]</span>
<span class="go"> [0.25 0.25]</span>
<span class="go"> [0.5  0.5 ]</span>
<span class="go"> [1.   1.  ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]))</span>
<span class="go">[[1.5 0. ]]</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler.fit" title="dask_ml.preprocessing.MinMaxScaler.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X,&nbsp;pandas.core.frame.DataFrame,&nbsp;…)</td>
<td>Compute the minimum and maximum to be used for later scaling.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler.fit_transform" title="dask_ml.preprocessing.MinMaxScaler.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler.get_params" title="dask_ml.preprocessing.MinMaxScaler.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler.inverse_transform" title="dask_ml.preprocessing.MinMaxScaler.inverse_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_transform</span></code></a>(X,&nbsp;…)</td>
<td>Undo the scaling of X according to feature_range.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler.partial_fit" title="dask_ml.preprocessing.MinMaxScaler.partial_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partial_fit</span></code></a>(X,&nbsp;pandas.core.frame.DataFrame,&nbsp;…)</td>
<td>Online computation of min and max on X for later scaling.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler.set_params" title="dask_ml.preprocessing.MinMaxScaler.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler.transform" title="dask_ml.preprocessing.MinMaxScaler.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X,&nbsp;pandas.core.frame.DataFrame,&nbsp;…)</td>
<td>Scale features of X according to feature_range.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.MinMaxScaler.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None</em><span class="sig-paren">)</span> &#x2192; dask_ml.preprocessing.data.MinMaxScaler<a class="headerlink" href="#dask_ml.preprocessing.MinMaxScaler.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the minimum and maximum to be used for later scaling.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The data used to compute the per-feature minimum and maximum
used for later scaling along the features axis.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">Ignored.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Fitted scaler.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.MinMaxScaler.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.MinMaxScaler.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to <cite>X</cite> and <cite>y</cite> with optional parameters <cite>fit_params</cite>
and returns a transformed version of <cite>X</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Input samples.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None</span></dt>
<dd><p class="first last">Target values (None for unsupervised transformations).</p>
</dd>
<dt><strong>**fit_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Additional fit parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray array of shape (n_samples, n_features_new)</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.MinMaxScaler.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.MinMaxScaler.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.MinMaxScaler.inverse_transform">
<code class="descname">inverse_transform</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None, copy: Optional[bool] = None</em><span class="sig-paren">)</span> &#x2192; Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]<a class="headerlink" href="#dask_ml.preprocessing.MinMaxScaler.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Undo the scaling of X according to feature_range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Input data that will be transformed. It cannot be sparse.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Xt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Transformed data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.MinMaxScaler.partial_fit">
<code class="descname">partial_fit</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.MinMaxScaler.partial_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Online computation of min and max on X for later scaling.</p>
<p>All of X is processed as a single batch. This is intended for cases
when <a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler.fit" title="dask_ml.preprocessing.MinMaxScaler.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> is not feasible due to very large number of
<cite>n_samples</cite> or because X is read from a continuous stream.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The data used to compute the mean and standard deviation
used for later scaling along the features axis.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">Ignored.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Fitted scaler.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.MinMaxScaler.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.MinMaxScaler.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="(in scikit-learn v0.24)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>). The latter have
parameters of the form <code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s
possible to update each component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>**params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Estimator parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">estimator instance</span></dt>
<dd><p class="first last">Estimator instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.MinMaxScaler.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None, copy: Optional[bool] = None</em><span class="sig-paren">)</span> &#x2192; Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]<a class="headerlink" href="#dask_ml.preprocessing.MinMaxScaler.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale features of X according to feature_range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Input data that will be transformed.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Xt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Transformed data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.RobustScaler">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">RobustScaler</code><span class="sig-paren">(</span><em>*</em>, <em>with_centering=True</em>, <em>with_scaling=True</em>, <em>quantile_range=(25.0</em>, <em>75.0)</em>, <em>copy=True</em>, <em>unit_variance=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.RobustScaler" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale features using statistics that are robust to outliers.</p>
<p>This Scaler removes the median and scales the data according to
the quantile range (defaults to IQR: Interquartile Range).
The IQR is the range between the 1st quartile (25th quantile)
and the 3rd quartile (75th quantile).</p>
<p>Centering and scaling happen independently on each feature by
computing the relevant statistics on the samples in the training
set. Median and interquartile range are then stored to be used on
later data using the <code class="docutils literal notranslate"><span class="pre">transform</span></code> method.</p>
<p>Standardization of a dataset is a common requirement for many
machine learning estimators. Typically this is done by removing the mean
and scaling to unit variance. However, outliers can often influence the
sample mean / variance in a negative way. In such cases, the median and
the interquartile range often give better results.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.17.</span></p>
</div>
<p>Read more in the <a class="reference external" href="https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-scaler" title="(in scikit-learn v0.24)"><span class="xref std std-ref">User Guide</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>with_centering</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, center the data before scaling.
This will cause <code class="docutils literal notranslate"><span class="pre">transform</span></code> to raise an exception when attempted on
sparse matrices, because centering them entails building a dense
matrix which in common use cases is likely to be too large to fit in
memory.</p>
</dd>
<dt><strong>with_scaling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, scale the data to interquartile range.</p>
</dd>
<dt><strong>quantile_range</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple (q_min, q_max), 0.0 &lt; q_min &lt; q_max &lt; 100.0,         default=(25.0, 75.0), == (1st quantile, 3rd quantile), == IQR</span></dt>
<dd><p class="first">Quantile range used to calculate <code class="docutils literal notranslate"><span class="pre">scale_</span></code>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.18.</span></p>
</div>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If False, try to avoid a copy and do inplace scaling instead.
This is not guaranteed to always work inplace; e.g. if the data is
not a NumPy array or scipy.sparse CSR matrix, a copy may still be
returned.</p>
</dd>
<dt><strong>unit_variance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=False</span></dt>
<dd><p class="first">If True, scale data so that normally distributed features have a
variance of 1. In general, if the difference between the x-values of
<code class="docutils literal notranslate"><span class="pre">q_max</span></code> and <code class="docutils literal notranslate"><span class="pre">q_min</span></code> for a standard normal distribution is greater
than 1, the dataset will be scaled down. If less than 1, the dataset
will be scaled up.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.24.</span></p>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>center_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of floats</span></dt>
<dd><p class="first last">The median value for each feature in the training set.</p>
</dd>
<dt><strong>scale_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of floats</span></dt>
<dd><p class="first">The (scaled) interquartile range for each feature in the training set.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.17: </span><em>scale_</em> attribute.</p>
</div>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">robust_scale</span></code></dt>
<dd>Equivalent function without the estimator API.</dd>
<dt><a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html#sklearn.decomposition.PCA" title="(in scikit-learn v0.24)"><code class="xref py py-class docutils literal notranslate"><span class="pre">PCA</span></code></a></dt>
<dd>Further removes the linear correlation across features with ‘whiten=True’.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For a comparison of the different scalers, transformers, and normalizers,
see <a class="reference external" href="https://scikit-learn.org/stable/auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py" title="(in scikit-learn v0.24)"><span class="xref std std-ref">examples/preprocessing/plot_all_scaling.py</span></a>.</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Median">https://en.wikipedia.org/wiki/Median</a>
<a class="reference external" href="https://en.wikipedia.org/wiki/Interquartile_range">https://en.wikipedia.org/wiki/Interquartile_range</a></p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">RobustScaler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span> <span class="o">=</span> <span class="n">RobustScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span>
<span class="go">RobustScaler()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[ 0. , -2. ,  0. ],</span>
<span class="go">       [-1. ,  0. ,  0.4],</span>
<span class="go">       [ 1. ,  0. , -1.6]])</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html#dask_ml.preprocessing.RobustScaler.fit" title="dask_ml.preprocessing.RobustScaler.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X,&nbsp;pandas.core.frame.DataFrame,&nbsp;…)</td>
<td>Compute the median and quantiles to be used for scaling.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html#dask_ml.preprocessing.RobustScaler.fit_transform" title="dask_ml.preprocessing.RobustScaler.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html#dask_ml.preprocessing.RobustScaler.get_params" title="dask_ml.preprocessing.RobustScaler.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html#dask_ml.preprocessing.RobustScaler.inverse_transform" title="dask_ml.preprocessing.RobustScaler.inverse_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_transform</span></code></a>(X,&nbsp;…)</td>
<td>Scale back the data to the original representation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html#dask_ml.preprocessing.RobustScaler.set_params" title="dask_ml.preprocessing.RobustScaler.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html#dask_ml.preprocessing.RobustScaler.transform" title="dask_ml.preprocessing.RobustScaler.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X,&nbsp;pandas.core.frame.DataFrame,&nbsp;…)</td>
<td>Center and scale the data.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.RobustScaler.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None</em><span class="sig-paren">)</span> &#x2192; dask_ml.preprocessing.data.RobustScaler<a class="headerlink" href="#dask_ml.preprocessing.RobustScaler.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median and quantiles to be used for scaling.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The data used to compute the median and quantiles
used for later scaling along the features axis.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">Ignored.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Fitted scaler.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.RobustScaler.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.RobustScaler.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to <cite>X</cite> and <cite>y</cite> with optional parameters <cite>fit_params</cite>
and returns a transformed version of <cite>X</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Input samples.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None</span></dt>
<dd><p class="first last">Target values (None for unsupervised transformations).</p>
</dd>
<dt><strong>**fit_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Additional fit parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray array of shape (n_samples, n_features_new)</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.RobustScaler.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.RobustScaler.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.RobustScaler.inverse_transform">
<code class="descname">inverse_transform</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]</em><span class="sig-paren">)</span> &#x2192; Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]<a class="headerlink" href="#dask_ml.preprocessing.RobustScaler.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale back the data to the original representation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><p class="first last">The data used to scale along the specified axis.</p>
</dd>
<dt><strong>This implementation was copied and modified from Scikit-Learn.</strong></dt>
<dd></dd>
<dt><strong>See License information here:</strong></dt>
<dd></dd>
<dt><strong>https://github.com/scikit-learn/scikit-learn/blob/main/README.rst</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.RobustScaler.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.RobustScaler.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="(in scikit-learn v0.24)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>). The latter have
parameters of the form <code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s
possible to update each component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>**params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Estimator parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">estimator instance</span></dt>
<dd><p class="first last">Estimator instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.RobustScaler.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]</em><span class="sig-paren">)</span> &#x2192; Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]<a class="headerlink" href="#dask_ml.preprocessing.RobustScaler.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Center and scale the data.</p>
<p>Can be called on sparse input, provided that <code class="docutils literal notranslate"><span class="pre">RobustScaler</span></code> has been
fitted to dense input and <code class="docutils literal notranslate"><span class="pre">with_centering=False</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix}</span></dt>
<dd><p class="first last">The data used to scale along the specified axis.</p>
</dd>
<dt><strong>This implementation was copied and modified from Scikit-Learn.</strong></dt>
<dd></dd>
<dt><strong>See License information here:</strong></dt>
<dd></dd>
<dt><strong>https://github.com/scikit-learn/scikit-learn/blob/main/README.rst</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.QuantileTransformer">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">QuantileTransformer</code><span class="sig-paren">(</span><em>*</em>, <em>n_quantiles=1000</em>, <em>output_distribution='uniform'</em>, <em>ignore_implicit_zeros=False</em>, <em>subsample=100000</em>, <em>random_state=None</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.QuantileTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms features using quantile information.</p>
<p>This implementation differs from the scikit-learn implementation
by using approximate quantiles. The scikit-learn docstring follows.</p>
<p>This method transforms the features to follow a uniform or a normal
distribution. Therefore, for a given feature, this transformation tends
to spread out the most frequent values. It also reduces the impact of
(marginal) outliers: this is therefore a robust preprocessing scheme.</p>
<p>The transformation is applied on each feature independently. First an
estimate of the cumulative distribution function of a feature is
used to map the original values to a uniform distribution. The obtained
values are then mapped to the desired output distribution using the
associated quantile function. Features values of new/unseen data that fall
below or above the fitted range will be mapped to the bounds of the output
distribution. Note that this transform is non-linear. It may distort linear
correlations between variables measured at the same scale but renders
variables measured at different scales more directly comparable.</p>
<p>Read more in the <a class="reference external" href="https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-transformer" title="(in scikit-learn v0.24)"><span class="xref std std-ref">User Guide</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.19.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n_quantiles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default=1000 or n_samples</span></dt>
<dd><p class="first last">Number of quantiles to be computed. It corresponds to the number
of landmarks used to discretize the cumulative distribution function.
If n_quantiles is larger than the number of samples, n_quantiles is set
to the number of samples as a larger number of quantiles does not give
a better approximation of the cumulative distribution function
estimator.</p>
</dd>
<dt><strong>output_distribution</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘uniform’, ‘normal’}, default=’uniform’</span></dt>
<dd><p class="first last">Marginal distribution for the transformed data. The choices are
‘uniform’ (default) or ‘normal’.</p>
</dd>
<dt><strong>ignore_implicit_zeros</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=False</span></dt>
<dd><p class="first last">Only applies to sparse matrices. If True, the sparse entries of the
matrix are discarded to compute the quantile statistics. If False,
these entries are treated as zeros.</p>
</dd>
<dt><strong>subsample</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default=1e5</span></dt>
<dd><p class="first last">Maximum number of samples used to estimate the quantiles for
computational efficiency. Note that the subsampling procedure may
differ for value-identical sparse and dense matrices.</p>
</dd>
<dt><strong>random_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, RandomState instance or None, default=None</span></dt>
<dd><p class="first last">Determines random number generation for subsampling and smoothing
noise.
Please see <code class="docutils literal notranslate"><span class="pre">subsample</span></code> for more details.
Pass an int for reproducible results across multiple function calls.
See <a class="reference external" href="https://scikit-learn.org/stable/glossary.html#term-random_state" title="(in scikit-learn v0.24)"><span class="xref std std-term">Glossary</span></a></p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">Set to False to perform inplace transformation and avoid a copy (if the
input is already a numpy array).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>n_quantiles_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The actual number of quantiles used to discretize the cumulative
distribution function.</p>
</dd>
<dt><strong>quantiles_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_quantiles, n_features)</span></dt>
<dd><p class="first last">The values corresponding the quantiles of reference.</p>
</dd>
<dt><strong>references_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_quantiles, )</span></dt>
<dd><p class="first last">Quantiles of references.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantile_transform</span></code></dt>
<dd>Equivalent function without the estimator API.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">PowerTransformer</span></code></dt>
<dd>Perform mapping to a normal distribution using a power transform.</dd>
<dt><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler" title="dask_ml.preprocessing.StandardScaler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StandardScaler</span></code></a></dt>
<dd>Perform standardization that is faster, but less robust to outliers.</dd>
<dt><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html#dask_ml.preprocessing.RobustScaler" title="dask_ml.preprocessing.RobustScaler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RobustScaler</span></code></a></dt>
<dd>Perform robust standardization that removes the influence of outliers but does not put outliers and inliers on the same scale.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>NaNs are treated as missing values: disregarded in fit, and maintained in
transform.</p>
<p>For a comparison of the different scalers, transformers, and normalizers,
see <a class="reference external" href="https://scikit-learn.org/stable/auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py" title="(in scikit-learn v0.24)"><span class="xref std std-ref">examples/preprocessing/plot_all_scaling.py</span></a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">QuantileTransformer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qt</span> <span class="o">=</span> <span class="n">QuantileTransformer</span><span class="p">(</span><span class="n">n_quantiles</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qt</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([...])</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.QuantileTransformer.html#dask_ml.preprocessing.QuantileTransformer.fit" title="dask_ml.preprocessing.QuantileTransformer.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Compute the quantiles used for transforming.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.QuantileTransformer.html#dask_ml.preprocessing.QuantileTransformer.fit_transform" title="dask_ml.preprocessing.QuantileTransformer.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.QuantileTransformer.html#dask_ml.preprocessing.QuantileTransformer.get_params" title="dask_ml.preprocessing.QuantileTransformer.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.QuantileTransformer.html#dask_ml.preprocessing.QuantileTransformer.inverse_transform" title="dask_ml.preprocessing.QuantileTransformer.inverse_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_transform</span></code></a>(X)</td>
<td>Back-projection to the original space.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.QuantileTransformer.html#dask_ml.preprocessing.QuantileTransformer.set_params" title="dask_ml.preprocessing.QuantileTransformer.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.QuantileTransformer.html#dask_ml.preprocessing.QuantileTransformer.transform" title="dask_ml.preprocessing.QuantileTransformer.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X)</td>
<td>Feature-wise transformation of the data.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.QuantileTransformer.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.QuantileTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the quantiles used for transforming.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The data used to scale along the features axis. If a sparse
matrix is provided, it will be converted into a sparse
<code class="docutils literal notranslate"><span class="pre">csc_matrix</span></code>. Additionally, the sparse matrix needs to be
nonnegative if <cite>ignore_implicit_zeros</cite> is False.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">Ignored.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Fitted transformer.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.QuantileTransformer.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.QuantileTransformer.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to <cite>X</cite> and <cite>y</cite> with optional parameters <cite>fit_params</cite>
and returns a transformed version of <cite>X</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Input samples.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None</span></dt>
<dd><p class="first last">Target values (None for unsupervised transformations).</p>
</dd>
<dt><strong>**fit_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Additional fit parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray array of shape (n_samples, n_features_new)</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.QuantileTransformer.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.QuantileTransformer.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.QuantileTransformer.inverse_transform">
<code class="descname">inverse_transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.QuantileTransformer.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Back-projection to the original space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The data used to scale along the features axis. If a sparse
matrix is provided, it will be converted into a sparse
<code class="docutils literal notranslate"><span class="pre">csc_matrix</span></code>. Additionally, the sparse matrix needs to be
nonnegative if <cite>ignore_implicit_zeros</cite> is False.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Xt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{ndarray, sparse matrix} of (n_samples, n_features)</span></dt>
<dd><p class="first last">The projected data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.QuantileTransformer.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.QuantileTransformer.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="(in scikit-learn v0.24)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>). The latter have
parameters of the form <code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s
possible to update each component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>**params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Estimator parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">estimator instance</span></dt>
<dd><p class="first last">Estimator instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.QuantileTransformer.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.QuantileTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Feature-wise transformation of the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The data used to scale along the features axis. If a sparse
matrix is provided, it will be converted into a sparse
<code class="docutils literal notranslate"><span class="pre">csc_matrix</span></code>. Additionally, the sparse matrix needs to be
nonnegative if <cite>ignore_implicit_zeros</cite> is False.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Xt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{ndarray, sparse matrix} of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The projected data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.Categorizer">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">Categorizer</code><span class="sig-paren">(</span><em>categories: Optional[dict] = None</em>, <em>columns: pandas.core.indexes.base.Index = None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.Categorizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform columns of a DataFrame to categorical dtype.</p>
<p>This is a useful pre-processing step for dummy, one-hot, or
categorical encoding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>categories</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mapping, optional</span></dt>
<dd><p class="first last">A dictionary mapping column name to instances of
<code class="docutils literal notranslate"><span class="pre">pandas.api.types.CategoricalDtype</span></code>. Alternatively, a
mapping of column name to <code class="docutils literal notranslate"><span class="pre">(categories,</span> <span class="pre">ordered)</span></code> tuples.</p>
</dd>
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence, optional</span></dt>
<dd><p class="first last">A sequence of column names to limit the categorization to.
This argument is ignored when <code class="docutils literal notranslate"><span class="pre">categories</span></code> is specified.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>columns_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Index</span></dt>
<dd><p class="first last">The columns that were categorized. Useful when <code class="docutils literal notranslate"><span class="pre">categories</span></code> is None,
and we detect the categorical and object columns</p>
</dd>
<dt><strong>categories_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">A dictionary mapping column names to dtypes. For pandas&gt;=0.21.0, the
values are instances of <code class="docutils literal notranslate"><span class="pre">pandas.api.types.CategoricalDtype</span></code>. For
older pandas, the values are tuples of <code class="docutils literal notranslate"><span class="pre">(categories,</span> <span class="pre">ordered)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This transformer only applies to <code class="docutils literal notranslate"><span class="pre">dask.DataFrame</span></code> and
<code class="docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>. By default, all object-type columns are converted to
categoricals. The set of categories will be the values present in the
column and the categoricals will be unordered. Pass <code class="docutils literal notranslate"><span class="pre">dtypes</span></code> to control
this behavior.</p>
<p>All other columns are included in the transformed output untouched.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">dask.DataFrame</span></code>, any unknown categoricals will become known.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ce</span> <span class="o">=</span> <span class="n">Categorizer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ce</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="o">.</span><span class="n">dtypes</span>
<span class="go">A       int64</span>
<span class="go">B    category</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ce</span><span class="o">.</span><span class="n">categories_</span>
<span class="go">{&#39;B&#39;: CategoricalDtype(categories=[&#39;a&#39;, &#39;b&#39;], ordered=False)}</span>
</pre></div>
</div>
<p>Using CategoricalDtypes for specifying the categories:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="kn">import</span> <span class="n">CategoricalDtype</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ce</span> <span class="o">=</span> <span class="n">Categorizer</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="n">CategoricalDtype</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ce</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">CategoricalDtype(categories=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], ordered=False)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.Categorizer.html#dask_ml.preprocessing.Categorizer.fit" title="dask_ml.preprocessing.Categorizer.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X,&nbsp;dask.dataframe.core.DataFrame],&nbsp;y,&nbsp;…)</td>
<td>Find the categorical columns.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.Categorizer.html#dask_ml.preprocessing.Categorizer.fit_transform" title="dask_ml.preprocessing.Categorizer.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.Categorizer.html#dask_ml.preprocessing.Categorizer.get_params" title="dask_ml.preprocessing.Categorizer.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.Categorizer.html#dask_ml.preprocessing.Categorizer.set_params" title="dask_ml.preprocessing.Categorizer.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.Categorizer.html#dask_ml.preprocessing.Categorizer.transform" title="dask_ml.preprocessing.Categorizer.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X,&nbsp;dask.dataframe.core.DataFrame],&nbsp;…)</td>
<td>Transform the columns in <code class="docutils literal notranslate"><span class="pre">X</span></code> according to <code class="docutils literal notranslate"><span class="pre">self.categories_</span></code>.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.Categorizer.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X: Union[pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None</em><span class="sig-paren">)</span> &#x2192; dask_ml.preprocessing.data.Categorizer<a class="headerlink" href="#dask_ml.preprocessing.Categorizer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the categorical columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame or dask.DataFrame</span></dt>
<dd></dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ignored</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>self</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.Categorizer.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.Categorizer.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to <cite>X</cite> and <cite>y</cite> with optional parameters <cite>fit_params</cite>
and returns a transformed version of <cite>X</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Input samples.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None</span></dt>
<dd><p class="first last">Target values (None for unsupervised transformations).</p>
</dd>
<dt><strong>**fit_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Additional fit parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray array of shape (n_samples, n_features_new)</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.Categorizer.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.Categorizer.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.Categorizer.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.Categorizer.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="(in scikit-learn v0.24)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>). The latter have
parameters of the form <code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s
possible to update each component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>**params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Estimator parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">estimator instance</span></dt>
<dd><p class="first last">Estimator instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.Categorizer.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X: Union[pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None</em><span class="sig-paren">)</span> &#x2192; Union[pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]<a class="headerlink" href="#dask_ml.preprocessing.Categorizer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the columns in <code class="docutils literal notranslate"><span class="pre">X</span></code> according to <code class="docutils literal notranslate"><span class="pre">self.categories_</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame or dask.DataFrame</span></dt>
<dd></dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ignored</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_trn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame or dask.DataFrame</span></dt>
<dd><p class="first last">Same type as the input. The columns in <code class="docutils literal notranslate"><span class="pre">self.categories_</span></code> will
be converted to categorical dtype.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.DummyEncoder">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">DummyEncoder</code><span class="sig-paren">(</span><em>columns: Optional[Sequence[Any]] = None</em>, <em>drop_first: bool = False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.DummyEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Dummy (one-hot) encode categorical columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence, optional</span></dt>
<dd><p class="first last">The columns to dummy encode. Must be categorical dtype.
Dummy encodes all categorical dtype columns by default.</p>
</dd>
<dt><strong>drop_first</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">Whether to drop the first category in each column.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>columns_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index</span></dt>
<dd><p class="first last">The columns in the training data before dummy encoding</p>
</dd>
<dt><strong>transformed_columns_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index</span></dt>
<dd><p class="first last">The columns in the training data after dummy encoding</p>
</dd>
<dt><strong>categorical_columns_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index</span></dt>
<dd><p class="first last">The categorical columns in the training data</p>
</dd>
<dt><strong>noncategorical_columns_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index</span></dt>
<dd><p class="first last">The rest of the columns in the training data</p>
</dd>
<dt><strong>categorical_blocks_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Mapping from column names to slice objects. The slices
represent the positions in the transformed array that the
categorical column ends up at</p>
</dd>
<dt><strong>dtypes_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">Dictionary mapping column name to either</p>
<ul class="last simple">
<li>instances of CategoricalDtype (pandas &gt;= 0.21.0)</li>
<li>tuples of (categories, ordered)</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This transformer only applies to dask and pandas DataFrames. For dask
DataFrames, all of your categoricals should be known.</p>
<p>The inverse transformation can be used on a dataframe or array.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                     <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">de</span> <span class="o">=</span> <span class="n">DummyEncoder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trn</span> <span class="o">=</span> <span class="n">de</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trn</span>
<span class="go">A  B_a  B_b</span>
<span class="go">0  1    1    0</span>
<span class="go">1  2    1    0</span>
<span class="go">2  3    1    0</span>
<span class="go">3  4    0    1</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">de</span><span class="o">.</span><span class="n">columns_</span>
<span class="go">Index([&#39;A&#39;, &#39;B&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">de</span><span class="o">.</span><span class="n">non_categorical_columns_</span>
<span class="go">Index([&#39;A&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">de</span><span class="o">.</span><span class="n">categorical_columns_</span>
<span class="go">Index([&#39;B&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">de</span><span class="o">.</span><span class="n">dtypes_</span>
<span class="go">{&#39;B&#39;: CategoricalDtype(categories=[&#39;a&#39;, &#39;b&#39;], ordered=False)}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">de</span><span class="o">.</span><span class="n">categorical_blocks_</span>
<span class="go">{&#39;B&#39;: slice(1, 3, None)}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">de</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">Dask DataFrame Structure:</span>
<span class="go">                A    B_a    B_b</span>
<span class="go">npartitions=2</span>
<span class="go">0              int64  uint8  uint8</span>
<span class="go">2                ...    ...    ...</span>
<span class="go">3                ...    ...    ...</span>
<span class="go">Dask Name: get_dummies, 4 tasks</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.DummyEncoder.html#dask_ml.preprocessing.DummyEncoder.fit" title="dask_ml.preprocessing.DummyEncoder.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X,&nbsp;dask.dataframe.core.DataFrame],&nbsp;y,&nbsp;…)</td>
<td>Determine the categorical columns to be dummy encoded.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.DummyEncoder.html#dask_ml.preprocessing.DummyEncoder.fit_transform" title="dask_ml.preprocessing.DummyEncoder.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.DummyEncoder.html#dask_ml.preprocessing.DummyEncoder.get_params" title="dask_ml.preprocessing.DummyEncoder.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.DummyEncoder.html#dask_ml.preprocessing.DummyEncoder.inverse_transform" title="dask_ml.preprocessing.DummyEncoder.inverse_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_transform</span></code></a>(X,&nbsp;…)</td>
<td>Inverse dummy-encode the columns in <cite>X</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.DummyEncoder.html#dask_ml.preprocessing.DummyEncoder.set_params" title="dask_ml.preprocessing.DummyEncoder.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.DummyEncoder.html#dask_ml.preprocessing.DummyEncoder.transform" title="dask_ml.preprocessing.DummyEncoder.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X,&nbsp;dask.dataframe.core.DataFrame],&nbsp;…)</td>
<td>Dummy encode the categorical columns in X</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.DummyEncoder.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X: Union[pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None</em><span class="sig-paren">)</span> &#x2192; dask_ml.preprocessing.data.DummyEncoder<a class="headerlink" href="#dask_ml.preprocessing.DummyEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the categorical columns to be dummy encoded.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame or dask.dataframe.DataFrame</span></dt>
<dd></dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ignored</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>self</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.DummyEncoder.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.DummyEncoder.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to <cite>X</cite> and <cite>y</cite> with optional parameters <cite>fit_params</cite>
and returns a transformed version of <cite>X</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Input samples.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None</span></dt>
<dd><p class="first last">Target values (None for unsupervised transformations).</p>
</dd>
<dt><strong>**fit_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Additional fit parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray array of shape (n_samples, n_features_new)</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.DummyEncoder.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.DummyEncoder.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.DummyEncoder.inverse_transform">
<code class="descname">inverse_transform</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]</em><span class="sig-paren">)</span> &#x2192; Union[pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]<a class="headerlink" href="#dask_ml.preprocessing.DummyEncoder.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse dummy-encode the columns in <cite>X</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array or dataframe</span></dt>
<dd><p class="first last">Either the NumPy, dask, or pandas version</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd><p class="first last">Dask array or dataframe will return a Dask DataFrame.
Numpy array or pandas dataframe will return a pandas DataFrame</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.DummyEncoder.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.DummyEncoder.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="(in scikit-learn v0.24)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>). The latter have
parameters of the form <code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s
possible to update each component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>**params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Estimator parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">estimator instance</span></dt>
<dd><p class="first last">Estimator instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.DummyEncoder.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X: Union[pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None</em><span class="sig-paren">)</span> &#x2192; Union[pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]<a class="headerlink" href="#dask_ml.preprocessing.DummyEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Dummy encode the categorical columns in X</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pd.DataFrame or dd.DataFrame</span></dt>
<dd></dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ignored</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transformed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pd.DataFrame or dd.DataFrame</span></dt>
<dd><p class="first last">Same type as the input</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.OrdinalEncoder">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">OrdinalEncoder</code><span class="sig-paren">(</span><em>columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OrdinalEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Ordinal (integer) encode categorical columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence, optional</span></dt>
<dd><p class="first last">The columns to encode. Must be categorical dtype.
Encodes all categorical dtype columns by default.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>columns_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index</span></dt>
<dd><p class="first last">The columns in the training data before/after encoding</p>
</dd>
<dt><strong>categorical_columns_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index</span></dt>
<dd><p class="first last">The categorical columns in the training data</p>
</dd>
<dt><strong>noncategorical_columns_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index</span></dt>
<dd><p class="first last">The rest of the columns in the training data</p>
</dd>
<dt><strong>dtypes_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">Dictionary mapping column name to either</p>
<ul class="last simple">
<li>instances of CategoricalDtype (pandas &gt;= 0.21.0)</li>
<li>tuples of (categories, ordered)</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This transformer only applies to dask and pandas DataFrames. For dask
DataFrames, all of your categoricals should be known.</p>
<p>The inverse transformation can be used on a dataframe or array.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                     <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">OrdinalEncoder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trn</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trn</span>
<span class="go">   A  B</span>
<span class="go">0  1  0</span>
<span class="go">1  2  0</span>
<span class="go">2  3  0</span>
<span class="go">3  4  1</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">columns_</span>
<span class="go">Index([&#39;A&#39;, &#39;B&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">non_categorical_columns_</span>
<span class="go">Index([&#39;A&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">categorical_columns_</span>
<span class="go">Index([&#39;B&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">dtypes_</span>
<span class="go">{&#39;B&#39;: CategoricalDtype(categories=[&#39;a&#39;, &#39;b&#39;], ordered=False)}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">Dask DataFrame Structure:</span>
<span class="go">                   A     B</span>
<span class="go">npartitions=2</span>
<span class="go">0              int64  int8</span>
<span class="go">2                ...   ...</span>
<span class="go">3                ...   ...</span>
<span class="go">Dask Name: assign, 8 tasks</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.OrdinalEncoder.html#dask_ml.preprocessing.OrdinalEncoder.fit" title="dask_ml.preprocessing.OrdinalEncoder.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X,&nbsp;dask.dataframe.core.DataFrame],&nbsp;y,&nbsp;…)</td>
<td>Determine the categorical columns to be encoded.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.OrdinalEncoder.html#dask_ml.preprocessing.OrdinalEncoder.fit_transform" title="dask_ml.preprocessing.OrdinalEncoder.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.OrdinalEncoder.html#dask_ml.preprocessing.OrdinalEncoder.get_params" title="dask_ml.preprocessing.OrdinalEncoder.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.OrdinalEncoder.html#dask_ml.preprocessing.OrdinalEncoder.inverse_transform" title="dask_ml.preprocessing.OrdinalEncoder.inverse_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_transform</span></code></a>(X,&nbsp;…)</td>
<td>Inverse ordinal-encode the columns in <cite>X</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.OrdinalEncoder.html#dask_ml.preprocessing.OrdinalEncoder.set_params" title="dask_ml.preprocessing.OrdinalEncoder.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.OrdinalEncoder.html#dask_ml.preprocessing.OrdinalEncoder.transform" title="dask_ml.preprocessing.OrdinalEncoder.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X,&nbsp;dask.dataframe.core.DataFrame],&nbsp;…)</td>
<td>Ordinal encode the categorical columns in X</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.OrdinalEncoder.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X: Union[pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None</em><span class="sig-paren">)</span> &#x2192; dask_ml.preprocessing.data.OrdinalEncoder<a class="headerlink" href="#dask_ml.preprocessing.OrdinalEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the categorical columns to be encoded.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame or dask.dataframe.DataFrame</span></dt>
<dd></dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ignored</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>self</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.OrdinalEncoder.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OrdinalEncoder.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to <cite>X</cite> and <cite>y</cite> with optional parameters <cite>fit_params</cite>
and returns a transformed version of <cite>X</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Input samples.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None</span></dt>
<dd><p class="first last">Target values (None for unsupervised transformations).</p>
</dd>
<dt><strong>**fit_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Additional fit parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray array of shape (n_samples, n_features_new)</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.OrdinalEncoder.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OrdinalEncoder.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.OrdinalEncoder.inverse_transform">
<code class="descname">inverse_transform</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]</em><span class="sig-paren">)</span> &#x2192; Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]<a class="headerlink" href="#dask_ml.preprocessing.OrdinalEncoder.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse ordinal-encode the columns in <cite>X</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array or dataframe</span></dt>
<dd><p class="first last">Either the NumPy, dask, or pandas version</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd><p class="first last">Dask array or dataframe will return a Dask DataFrame.
Numpy array or pandas dataframe will return a pandas DataFrame</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.OrdinalEncoder.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OrdinalEncoder.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="(in scikit-learn v0.24)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>). The latter have
parameters of the form <code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s
possible to update each component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>**params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Estimator parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">estimator instance</span></dt>
<dd><p class="first last">Estimator instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.OrdinalEncoder.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X: Union[pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None</em><span class="sig-paren">)</span> &#x2192; Union[pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]<a class="headerlink" href="#dask_ml.preprocessing.OrdinalEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Ordinal encode the categorical columns in X</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pd.DataFrame or dd.DataFrame</span></dt>
<dd></dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ignored</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transformed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pd.DataFrame or dd.DataFrame</span></dt>
<dd><p class="first last">Same type as the input</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.LabelEncoder">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">LabelEncoder</code><span class="sig-paren">(</span><em>use_categorical: bool = True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.LabelEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode labels with value between 0 and n_classes-1.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This differs from the scikit-learn version for Categorical data.
When passed a categorical <cite>y</cite>, this implementation will use the
categorical information for the label encoding and transformation.
You will receive different answers when</p>
<ol class="arabic simple">
<li>Your categories are not monotonically increasing</li>
<li>You have unobserved categories</li>
</ol>
<p class="last">Specify <code class="docutils literal notranslate"><span class="pre">use_categorical=False</span></code> to recover the scikit-learn behavior.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>use_categorical</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default True</span></dt>
<dd><p class="first last">Whether to use the categorical dtype information when <cite>y</cite> is a
dask or pandas Series with a categorical dtype.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>classes_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of shape (n_class,)</span></dt>
<dd><p class="first last">Holds the label for each class.</p>
</dd>
<dt><strong>dtype_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Optional CategoricalDtype</span></dt>
<dd><p class="first last">For Categorical <cite>y</cite>, the dtype is stored here.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p><cite>LabelEncoder</cite> can be used to normalize labels.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask_ml</span> <span class="kn">import</span> <span class="n">preprocessing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">LabelEncoder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span><span class="o">.</span><span class="n">fit</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="go">LabelEncoder()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span><span class="o">.</span><span class="n">classes_</span>
<span class="go">array([1, 2, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span> <span class="c1">#doctest: +ELLIPSIS</span>
<span class="go">array([0, 0, 1, 2]...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([1, 1, 2, 6])</span>
</pre></div>
</div>
<p>It can also be used to transform non-numerical labels (as long as they are
hashable and comparable) to numerical labels.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">le</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">LabelEncoder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span><span class="o">.</span><span class="n">fit</span><span class="p">([</span><span class="s2">&quot;paris&quot;</span><span class="p">,</span> <span class="s2">&quot;paris&quot;</span><span class="p">,</span> <span class="s2">&quot;tokyo&quot;</span><span class="p">,</span> <span class="s2">&quot;amsterdam&quot;</span><span class="p">])</span>
<span class="go">LabelEncoder()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">le</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span>
<span class="go">[&#39;amsterdam&#39;, &#39;paris&#39;, &#39;tokyo&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="s2">&quot;tokyo&quot;</span><span class="p">,</span> <span class="s2">&quot;tokyo&quot;</span><span class="p">,</span> <span class="s2">&quot;paris&quot;</span><span class="p">])</span> <span class="c1">#doctest: +ELLIPSIS</span>
<span class="go">array([2, 2, 1]...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">le</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">[&#39;tokyo&#39;, &#39;tokyo&#39;, &#39;paris&#39;]</span>
</pre></div>
</div>
<p>When using Dask, we strongly recommend using a Categorical dask Series if
possible. This avoids a (potentially expensive) scan of the values and
enables a faster <cite>transform</cite> algorithm.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">dd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;category&#39;</span><span class="p">),</span>
<span class="gp">... </span>                      <span class="n">npartitions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">dask.array&lt;values, shape=(nan,), dtype=int8, chunksize=(nan,)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([0, 0, 1], dtype=int8)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.LabelEncoder.html#dask_ml.preprocessing.LabelEncoder.fit" title="dask_ml.preprocessing.LabelEncoder.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(y,&nbsp;dask.dataframe.core.Series,&nbsp;…)</td>
<td>Fit label encoder.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.LabelEncoder.html#dask_ml.preprocessing.LabelEncoder.fit_transform" title="dask_ml.preprocessing.LabelEncoder.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(y,&nbsp;dask.dataframe.core.Series,&nbsp;…)</td>
<td>Fit label encoder and return encoded labels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.LabelEncoder.html#dask_ml.preprocessing.LabelEncoder.get_params" title="dask_ml.preprocessing.LabelEncoder.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.LabelEncoder.html#dask_ml.preprocessing.LabelEncoder.inverse_transform" title="dask_ml.preprocessing.LabelEncoder.inverse_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_transform</span></code></a>(y,&nbsp;…)</td>
<td>Transform labels back to original encoding.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.LabelEncoder.html#dask_ml.preprocessing.LabelEncoder.set_params" title="dask_ml.preprocessing.LabelEncoder.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.LabelEncoder.html#dask_ml.preprocessing.LabelEncoder.transform" title="dask_ml.preprocessing.LabelEncoder.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(y,&nbsp;dask.dataframe.core.Series,&nbsp;…)</td>
<td>Transform labels to normalized encoding.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.LabelEncoder.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series]</em><span class="sig-paren">)</span> &#x2192; dask_ml.preprocessing.label.LabelEncoder<a class="headerlink" href="#dask_ml.preprocessing.LabelEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit label encoder.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,)</span></dt>
<dd><p class="first last">Target values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">returns an instance of self.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.LabelEncoder.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series]</em><span class="sig-paren">)</span> &#x2192; Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series]<a class="headerlink" href="#dask_ml.preprocessing.LabelEncoder.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit label encoder and return encoded labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,)</span></dt>
<dd><p class="first last">Target values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,)</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.LabelEncoder.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.LabelEncoder.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.LabelEncoder.inverse_transform">
<code class="descname">inverse_transform</code><span class="sig-paren">(</span><em>y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series]</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.LabelEncoder.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform labels back to original encoding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_samples,)</span></dt>
<dd><p class="first last">Target values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_samples,)</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.LabelEncoder.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.LabelEncoder.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="(in scikit-learn v0.24)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>). The latter have
parameters of the form <code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s
possible to update each component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>**params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Estimator parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">estimator instance</span></dt>
<dd><p class="first last">Estimator instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.LabelEncoder.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series]</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.LabelEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform labels to normalized encoding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,)</span></dt>
<dd><p class="first last">Target values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,)</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.OneHotEncoder">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">OneHotEncoder</code><span class="sig-paren">(</span><em>n_values: Optional[int] = None, categorical_features: Optional[pandas.core.arrays.categorical.Categorical] = None, categories: Union[str, ArrayLike] = 'auto', drop: Optional[bool] = None, sparse: bool = True, dtype: Union[numpy.dtype, None, type, numpy.typing._dtype_like._SupportsDType, str, Tuple[Any, int], Tuple[Any, Union[int, Sequence[int]]], List[Any], numpy.typing._dtype_like._DTypeDict, Tuple[Any, Any]] = &lt;class 'numpy.float64'&gt;, handle_unknown: str = 'error'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OneHotEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode categorical integer features as a one-hot numeric array.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.8.0.</span></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This requires scikit-learn 0.20.0 or newer.</p>
</div>
<p>The input to this transformer should be an array-like of integers, strings,
or categoricals, denoting the values taken on by categorical (discrete)
features. The features are encoded using a one-hot (aka ‘one-of-K’ or
‘dummy’) encoding scheme. This creates a binary column for each category
and returns a sparse matrix or dense array.</p>
<p>By default, the encoder derives the categories based on</p>
<ol class="arabic simple">
<li>For arrays, the unique values in each feature</li>
<li>For DataFrames, the CategoricalDtype information for each feature</li>
</ol>
<p>Alternatively, for arrays, you can also specify the <cite>categories</cite> manually.</p>
<p>This encoding is needed for feeding categorical data to many scikit-learn
estimators, notably linear models and SVMs with the standard kernels.</p>
<p>Note: a one-hot encoding of y labels should use a LabelBinarizer
instead.</p>
<p>Read more in the <a class="reference external" href="https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-categorical-features" title="(in scikit-learn v0.24)"><span class="xref std std-ref">User Guide</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>categories</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘auto’ or a list of lists/arrays of values.</span></dt>
<dd><p class="first">Categories (unique values) per feature:</p>
<ul class="simple">
<li>‘auto’ : Determine categories automatically from the training data.</li>
<li>list : <code class="docutils literal notranslate"><span class="pre">categories[i]</span></code> holds the categories expected in the ith
column. The passed categories should not mix strings and numeric
values within a single feature, and should be sorted in case of
numeric values.</li>
</ul>
<p class="last">The used categories can be found in the <code class="docutils literal notranslate"><span class="pre">categories_</span></code> attribute.</p>
</dd>
<dt><strong>drop</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None, default=None</span></dt>
<dd><p class="first last">The option to drop one of the categories per feature is not yet supported.</p>
</dd>
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default=True</span></dt>
<dd><p class="first last">Will return sparse matrix if set True else will return an array.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number type, default=np.float64</span></dt>
<dd><p class="first last">Desired dtype of output.</p>
</dd>
<dt><strong>handle_unknown</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘error’</span></dt>
<dd><p class="first last">Whether to raise an error or ignore if an unknown categorical feature
is present during transform (default is to raise). The option to
ignore unknown categories is not currently implemented.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>categories_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of arrays</span></dt>
<dd><p class="first last">The categories of each feature determined during fitting
(in order of the features in X and corresponding with the output
of <code class="docutils literal notranslate"><span class="pre">transform</span></code>).</p>
</dd>
<dt><strong>dtypes_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of dtypes</span></dt>
<dd><p class="first last">For DataFrame input, the CategoricalDtype information associated
with each feature. For arrays, this is a list of Nones.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>There are a few differences from scikit-learn.</p>
<p class="rubric">Examples</p>
<p>Given a dataset with two features, we let the encoder find the unique
values per feature and transform the data to a binary one-hot encoding.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask_ml.preprocessing</span> <span class="kn">import</span> <span class="n">OneHotEncoder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">OneHotEncoder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="s1">&#39;A&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]]),</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">... </span><span class="c1"># doctest: +ELLIPSIS</span>
<span class="go">OneHotEncoder(categorical_features=None, categories=None,</span>
<span class="go">       dtype=&lt;... &#39;numpy.float64&#39;&gt;, handle_unknown=&#39;error&#39;,</span>
<span class="go">       n_values=None, sparse=True)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">categories_</span>
<span class="go">[array([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;], dtype=&#39;&lt;U1&#39;)]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">dask.array&lt;concatenate, shape=(4, 3), dtype=float64, chunksize=(2, 3)&gt;</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dask_ml.preprocessing.OneHotEncoder.fit" title="dask_ml.preprocessing.OneHotEncoder.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X,&nbsp;pandas.core.frame.DataFrame,&nbsp;…)</td>
<td>Fit OneHotEncoder to X.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dask_ml.preprocessing.OneHotEncoder.fit_transform" title="dask_ml.preprocessing.OneHotEncoder.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit OneHotEncoder to X, then transform X.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dask_ml.preprocessing.OneHotEncoder.get_feature_names" title="dask_ml.preprocessing.OneHotEncoder.get_feature_names"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_feature_names</span></code></a>([input_features])</td>
<td>Return feature names for output features.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dask_ml.preprocessing.OneHotEncoder.get_params" title="dask_ml.preprocessing.OneHotEncoder.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>(deep)</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dask_ml.preprocessing.OneHotEncoder.inverse_transform" title="dask_ml.preprocessing.OneHotEncoder.inverse_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_transform</span></code></a>(X)</td>
<td>Convert the data back to the original representation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dask_ml.preprocessing.OneHotEncoder.set_params" title="dask_ml.preprocessing.OneHotEncoder.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dask_ml.preprocessing.OneHotEncoder.transform" title="dask_ml.preprocessing.OneHotEncoder.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X,&nbsp;pandas.core.frame.DataFrame,&nbsp;…)</td>
<td>Transform X using one-hot encoding.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.OneHotEncoder.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None</em><span class="sig-paren">)</span> &#x2192; dask_ml.preprocessing._encoders.OneHotEncoder<a class="headerlink" href="#dask_ml.preprocessing.OneHotEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit OneHotEncoder to X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_samples, n_features]</span></dt>
<dd><p class="first last">The data to determine the categories of each feature.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">Ignored. This parameter exists only for compatibility with
<a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="(in scikit-learn v0.24)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>self</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.OneHotEncoder.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OneHotEncoder.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit OneHotEncoder to X, then transform X.</p>
<p>Equivalent to fit(X).transform(X) but more convenient.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_samples, n_features]</span></dt>
<dd><p class="first last">The data to encode.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">Ignored. This parameter exists only for compatibility with
<a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="(in scikit-learn v0.24)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sparse matrix if sparse=True else a 2-d array</span></dt>
<dd><p class="first last">Transformed input.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.OneHotEncoder.get_feature_names">
<code class="descname">get_feature_names</code><span class="sig-paren">(</span><em>input_features=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OneHotEncoder.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return feature names for output features.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>input_features</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str of shape (n_features,)</span></dt>
<dd><p class="first last">String names for input features if available. By default,
“x0”, “x1”, … “xn_features” is used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output_feature_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_output_features,)</span></dt>
<dd><p class="first last">Array of feature names.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.OneHotEncoder.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep: bool = True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OneHotEncoder.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.OneHotEncoder.inverse_transform">
<code class="descname">inverse_transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OneHotEncoder.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the data back to the original representation.</p>
<p>In case unknown categories are encountered (all zeros in the
one-hot encoding), <code class="docutils literal notranslate"><span class="pre">None</span></code> is used to represent this category.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like or sparse matrix, shape [n_samples, n_encoded_features]</span></dt>
<dd><p class="first last">The transformed data.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_tr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_samples, n_features]</span></dt>
<dd><p class="first last">Inverse transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.OneHotEncoder.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.OneHotEncoder.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="(in scikit-learn v0.24)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>). The latter have
parameters of the form <code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s
possible to update each component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>**params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Estimator parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">estimator instance</span></dt>
<dd><p class="first last">Estimator instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.OneHotEncoder.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]</em><span class="sig-paren">)</span> &#x2192; Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]<a class="headerlink" href="#dask_ml.preprocessing.OneHotEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform X using one-hot encoding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_samples, n_features]</span></dt>
<dd><p class="first last">The data to encode.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sparse matrix if sparse=True else a 2-d array</span></dt>
<dd><p class="first last">Transformed input.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.PolynomialFeatures">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">PolynomialFeatures</code><span class="sig-paren">(</span><em>degree: int = 2</em>, <em>interaction_only: bool = False</em>, <em>include_bias: bool = True</em>, <em>preserve_dataframe: bool = False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.PolynomialFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate polynomial and interaction features.</p>
<blockquote>
<div>Generate a new feature matrix consisting of all polynomial combinations
of the features with degree less than or equal to the specified degree.
For example, if an input sample is two dimensional and of the form
[a, b], the degree-2 polynomial features are [1, a, b, a^2, ab, b^2].</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>degree</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default=2</span></dt>
<dd><blockquote class="first">
<div><p>The degree of the polynomial features.</p>
</div></blockquote>
<dl class="last docutils">
<dt>interaction_only <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=False</span></dt>
<dd><p class="first last">If true, only interaction features are produced: features that are
products of at most <code class="docutils literal notranslate"><span class="pre">degree</span></code> <em>distinct</em> input features (so not
<code class="docutils literal notranslate"><span class="pre">x[1]</span> <span class="pre">**</span> <span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">x[0]</span> <span class="pre">*</span> <span class="pre">x[2]</span> <span class="pre">**</span> <span class="pre">3</span></code>, etc.).</p>
</dd>
<dt>include_bias <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True (default), then include a bias column, the feature in which
all polynomial powers are zero (i.e. a column of ones - acts as an
intercept term in a linear model).</p>
</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’}, default=’C’</span></dt>
<dd><p class="first">Order of output array in the dense case. ‘F’ order is faster to
compute, but may slow down subsequent estimators.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.21.</span></p>
</div>
</dd>
</dl>
</dd>
<dt><strong>preserve_dataframe</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">If True, preserve pandas and dask dataframes after transforming.
Using False (default) returns numpy or dask arrays and mimics
sklearn’s default behaviour</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>powers_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_output_features, n_input_features)</span></dt>
<dd><blockquote class="first">
<div><p>powers_[i, j] is the exponent of the jth input in the ith output.</p>
</div></blockquote>
<dl class="last docutils">
<dt><a href="#id2"><span class="problematic" id="id3">n_input_features_</span></a> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The total number of input features.</p>
</dd>
<dt><a href="#id4"><span class="problematic" id="id5">n_output_features_</span></a> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The total number of polynomial output features. The number of output
features is computed by iterating over all suitably sized combinations
of input features.</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Be aware that the number of features in the output array scales
polynomially in the number of features of the input array, and
exponentially in the degree. High degrees can cause overfitting.</p>
<p>See <a class="reference external" href="https://scikit-learn.org/stable/auto_examples/linear_model/plot_polynomial_interpolation.html#sphx-glr-auto-examples-linear-model-plot-polynomial-interpolation-py" title="(in scikit-learn v0.24)"><span class="xref std std-ref">examples/linear_model/plot_polynomial_interpolation.py</span></a></p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">PolynomialFeatures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poly</span> <span class="o">=</span> <span class="n">PolynomialFeatures</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poly</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[ 1.,  0.,  1.,  0.,  0.,  1.],</span>
<span class="go">       [ 1.,  2.,  3.,  4.,  6.,  9.],</span>
<span class="go">       [ 1.,  4.,  5., 16., 20., 25.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poly</span> <span class="o">=</span> <span class="n">PolynomialFeatures</span><span class="p">(</span><span class="n">interaction_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poly</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[ 1.,  0.,  1.,  0.],</span>
<span class="go">       [ 1.,  2.,  3.,  6.],</span>
<span class="go">       [ 1.,  4.,  5., 20.]])</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.PolynomialFeatures.html#dask_ml.preprocessing.PolynomialFeatures.fit" title="dask_ml.preprocessing.PolynomialFeatures.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X,&nbsp;pandas.core.frame.DataFrame,&nbsp;…)</td>
<td>Compute number of output features.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.PolynomialFeatures.html#dask_ml.preprocessing.PolynomialFeatures.fit_transform" title="dask_ml.preprocessing.PolynomialFeatures.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.PolynomialFeatures.html#dask_ml.preprocessing.PolynomialFeatures.get_feature_names" title="dask_ml.preprocessing.PolynomialFeatures.get_feature_names"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_feature_names</span></code></a>([input_features])</td>
<td>Return feature names for output features</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.PolynomialFeatures.html#dask_ml.preprocessing.PolynomialFeatures.get_params" title="dask_ml.preprocessing.PolynomialFeatures.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.PolynomialFeatures.html#dask_ml.preprocessing.PolynomialFeatures.set_params" title="dask_ml.preprocessing.PolynomialFeatures.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.PolynomialFeatures.html#dask_ml.preprocessing.PolynomialFeatures.transform" title="dask_ml.preprocessing.PolynomialFeatures.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X,&nbsp;pandas.core.frame.DataFrame,&nbsp;…)</td>
<td>Transform data to polynomial features</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.PolynomialFeatures.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None</em><span class="sig-paren">)</span> &#x2192; dask_ml.preprocessing.data.PolynomialFeatures<a class="headerlink" href="#dask_ml.preprocessing.PolynomialFeatures.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute number of output features.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The data.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">Ignored.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Fitted transformer.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.PolynomialFeatures.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.PolynomialFeatures.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to <cite>X</cite> and <cite>y</cite> with optional parameters <cite>fit_params</cite>
and returns a transformed version of <cite>X</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Input samples.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None</span></dt>
<dd><p class="first last">Target values (None for unsupervised transformations).</p>
</dd>
<dt><strong>**fit_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Additional fit parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray array of shape (n_samples, n_features_new)</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.PolynomialFeatures.get_feature_names">
<code class="descname">get_feature_names</code><span class="sig-paren">(</span><em>input_features=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.PolynomialFeatures.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return feature names for output features</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>input_features</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str of shape (n_features,), default=None</span></dt>
<dd><p class="first last">String names for input features if available. By default,
“x0”, “x1”, … “xn_features” is used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output_feature_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str of shape (n_output_features,)</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.PolynomialFeatures.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.PolynomialFeatures.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.PolynomialFeatures.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.PolynomialFeatures.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="(in scikit-learn v0.24)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>). The latter have
parameters of the form <code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s
possible to update each component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>**params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Estimator parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">estimator instance</span></dt>
<dd><p class="first last">Estimator instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.PolynomialFeatures.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X: Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame], y: Union[ArrayLike, dask.dataframe.core.Series, pandas.core.series.Series, None] = None</em><span class="sig-paren">)</span> &#x2192; Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]<a class="headerlink" href="#dask_ml.preprocessing.PolynomialFeatures.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform data to polynomial features</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt>
<dd><p class="first">The data to transform, row by row.</p>
<p>Prefer CSR over CSC for sparse input (for speed), but CSC is
required if the degree is 4 or higher. If the degree is less than
4 and the input format is CSC, it will be converted to CSR, have
its polynomial features generated, then converted back to CSC.</p>
<p class="last">If the degree is 2 or 3, the method described in “Leveraging
Sparsity to Speed Up Polynomial Feature Expansions of CSR Matrices
Using K-Simplex Numbers” by Andrew Nystrom and John Hughes is
used, which is much faster than the method used on CSC input. For
this reason, a CSC input will be converted to CSR, and the output
will be converted back to CSC prior to being returned, hence the
preference of CSR.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>XP</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{ndarray, sparse matrix} of shape (n_samples, NP)</span></dt>
<dd><p class="first last">The matrix of features, where NP is the number of polynomial
features generated from the combination of inputs. If a sparse
matrix is provided, it will be converted into a sparse
<code class="docutils literal notranslate"><span class="pre">csr_matrix</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dask_ml.preprocessing.BlockTransformer">
<em class="property">class </em><code class="descclassname">dask_ml.preprocessing.</code><code class="descname">BlockTransformer</code><span class="sig-paren">(</span><em>func: Callable[[...], Union[ArrayLike, pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame]], *, validate: bool = False, **kw_args</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.BlockTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a transformer from a an arbitrary callable</p>
<p>The BlockTransformer forwards the blocks of the X arguments to a user-defined
callable and returns the result of this operation.
This is useful for stateless operations, that can be performed on the cell or
block level, such as taking the log of frequencies. In general the transformer
is not suitable for e.g. standardization tasks as this requires information for
a complete column.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">The callable to use for the transformation.</p>
</dd>
<dt><strong>validate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional default=False</span></dt>
<dd><blockquote class="first">
<div><p>Indicate that the input X array should be checked before calling</p>
</div></blockquote>
<p class="last"><code class="docutils literal notranslate"><span class="pre">func</span></code>.</p>
</dd>
<dt><strong>kw_args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd><p class="first last">Dictionary of additional keyword arguments to pass to func.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask_ml.preprocessing</span> <span class="kn">import</span> <span class="n">BlockTransformer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">timeseries</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="gp">... </span><span class="c1"># doctest: +SKIP</span>
<span class="go">Dask DataFrame Structure:</span>
<span class="go">                   id    name        x        y</span>
<span class="go">npartitions=30</span>
<span class="go">2000-01-01      int64  object  float64  float64</span>
<span class="go">2000-01-02        ...     ...      ...      ...</span>
<span class="gp">... </span>              <span class="o">...</span>     <span class="o">...</span>      <span class="o">...</span>      <span class="o">...</span>
<span class="go">2000-01-30        ...     ...      ...      ...</span>
<span class="go">2000-01-31        ...     ...      ...      ...</span>
<span class="go">Dask Name: make-timeseries, 30 tasks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trn</span> <span class="o">=</span> <span class="n">BlockTransformer</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">hash_pandas_object</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trn</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="gp">... </span><span class="c1"># doctest: +ELLIPSIS</span>
<span class="go">Dask Series Structure:</span>
<span class="go">npartitions=30</span>
<span class="go">2000-01-01    uint64</span>
<span class="go">2000-01-02       ...</span>
<span class="go">            ...</span>
<span class="go">2000-01-30       ...</span>
<span class="go">2000-01-31       ...</span>
<span class="go">dtype: uint64</span>
<span class="go">Dask Name: hash_pandas_object, 60 tasks</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.BlockTransformer.html#dask_ml.preprocessing.BlockTransformer.fit_transform" title="dask_ml.preprocessing.BlockTransformer.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.BlockTransformer.html#dask_ml.preprocessing.BlockTransformer.get_params" title="dask_ml.preprocessing.BlockTransformer.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.BlockTransformer.html#dask_ml.preprocessing.BlockTransformer.set_params" title="dask_ml.preprocessing.BlockTransformer.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="43%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>fit</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>transform</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.preprocessing.BlockTransformer.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.BlockTransformer.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to <cite>X</cite> and <cite>y</cite> with optional parameters <cite>fit_params</cite>
and returns a transformed version of <cite>X</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Input samples.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None</span></dt>
<dd><p class="first last">Target values (None for unsupervised transformations).</p>
</dd>
<dt><strong>**fit_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Additional fit parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray array of shape (n_samples, n_features_new)</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.BlockTransformer.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.BlockTransformer.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.preprocessing.BlockTransformer.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.preprocessing.BlockTransformer.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="(in scikit-learn v0.24)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>). The latter have
parameters of the form <code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s
possible to update each component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>**params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Estimator parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">estimator instance</span></dt>
<dd><p class="first last">Estimator instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler" title="dask_ml.preprocessing.StandardScaler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.StandardScaler</span></code></a>(*[,&nbsp;copy,&nbsp;…])</td>
<td>Standardize features by removing the mean and scaling to unit variance</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.RobustScaler.html#dask_ml.preprocessing.RobustScaler" title="dask_ml.preprocessing.RobustScaler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.RobustScaler</span></code></a>(*[,&nbsp;…])</td>
<td>Scale features using statistics that are robust to outliers.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.MinMaxScaler.html#dask_ml.preprocessing.MinMaxScaler" title="dask_ml.preprocessing.MinMaxScaler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.MinMaxScaler</span></code></a>([feature_range,&nbsp;…])</td>
<td>Transform features by scaling each feature to a given range.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.QuantileTransformer.html#dask_ml.preprocessing.QuantileTransformer" title="dask_ml.preprocessing.QuantileTransformer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.QuantileTransformer</span></code></a>(*[,&nbsp;…])</td>
<td>Transforms features using quantile information.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.StandardScaler.html#dask_ml.preprocessing.StandardScaler" title="dask_ml.preprocessing.StandardScaler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.StandardScaler</span></code></a>(*[,&nbsp;copy,&nbsp;…])</td>
<td>Standardize features by removing the mean and scaling to unit variance</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.Categorizer.html#dask_ml.preprocessing.Categorizer" title="dask_ml.preprocessing.Categorizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.Categorizer</span></code></a>(categories,&nbsp;columns)</td>
<td>Transform columns of a DataFrame to categorical dtype.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.DummyEncoder.html#dask_ml.preprocessing.DummyEncoder" title="dask_ml.preprocessing.DummyEncoder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.DummyEncoder</span></code></a>(columns,&nbsp;drop_first)</td>
<td>Dummy (one-hot) encode categorical columns.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.OrdinalEncoder.html#dask_ml.preprocessing.OrdinalEncoder" title="dask_ml.preprocessing.OrdinalEncoder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.OrdinalEncoder</span></code></a>([columns])</td>
<td>Ordinal (integer) encode categorical columns.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.LabelEncoder.html#dask_ml.preprocessing.LabelEncoder" title="dask_ml.preprocessing.LabelEncoder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.LabelEncoder</span></code></a>(use_categorical)</td>
<td>Encode labels with value between 0 and n_classes-1.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.preprocessing.PolynomialFeatures.html#dask_ml.preprocessing.PolynomialFeatures" title="dask_ml.preprocessing.PolynomialFeatures"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.PolynomialFeatures</span></code></a>(degree,&nbsp;…)</td>
<td>Generate polynomial and interaction features.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.preprocessing.BlockTransformer.html#dask_ml.preprocessing.BlockTransformer" title="dask_ml.preprocessing.BlockTransformer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing.BlockTransformer</span></code></a>(func,&nbsp;…)</td>
<td>Construct a transformer from a an arbitrary callable</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dask-ml-feature-extraction-text-feature-extraction">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.feature_extraction.text</span></code>: Feature extraction<a class="headerlink" href="#dask-ml-feature-extraction-text-feature-extraction" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.feature_extraction.text.CountVectorizer.html#dask_ml.feature_extraction.text.CountVectorizer" title="dask_ml.feature_extraction.text.CountVectorizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature_extraction.text.CountVectorizer</span></code></a>(*[,&nbsp;…])</td>
<td>Convert a collection of text documents to a matrix of token counts</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.feature_extraction.text.HashingVectorizer.html#dask_ml.feature_extraction.text.HashingVectorizer" title="dask_ml.feature_extraction.text.HashingVectorizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature_extraction.text.HashingVectorizer</span></code></a>(*)</td>
<td>Convert a collection of text documents to a matrix of token occurrences</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.feature_extraction.text.FeatureHasher.html#dask_ml.feature_extraction.text.FeatureHasher" title="dask_ml.feature_extraction.text.FeatureHasher"><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature_extraction.text.FeatureHasher</span></code></a>([…])</td>
<td>Implements feature hashing, aka the hashing trick.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dask-ml-compose-composite-estimators">
<h2><a class="reference internal" href="#module-dask_ml.compose" title="dask_ml.compose"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.compose</span></code></a>: Composite Estimators<a class="headerlink" href="#dask-ml-compose-composite-estimators" title="Permalink to this headline">¶</a></h2>
<p>Meta-estimators for building composite models with transformers.</p>
<span class="target" id="module-dask_ml.compose"></span><p>Meta-estimators for composing models with multiple transformers.</p>
<p>These estimators are useful for working with heterogenous tabular data.</p>
<dl class="class">
<dt id="dask_ml.compose.ColumnTransformer">
<em class="property">class </em><code class="descclassname">dask_ml.compose.</code><code class="descname">ColumnTransformer</code><span class="sig-paren">(</span><em>transformers</em>, <em>remainder='drop'</em>, <em>sparse_threshold=0.3</em>, <em>n_jobs=1</em>, <em>transformer_weights=None</em>, <em>preserve_dataframe=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.compose.ColumnTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies transformers to columns of an array or pandas DataFrame.</p>
<p>EXPERIMENTAL: some behaviors may change between releases without
deprecation.</p>
<p>This estimator allows different columns or column subsets of the input
to be transformed separately and the results combined into a single
feature space.
This is useful for heterogeneous or columnar data, to combine several
feature extraction mechanisms or transformations into a single transformer.</p>
<p>Read more in the <a class="reference external" href="https://scikit-learn.org/stable/modules/compose.html#column-transformer" title="(in scikit-learn v0.24)"><span class="xref std std-ref">User Guide</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This requires scikit-learn 0.20.0 or newer.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>transformers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd><p class="first">List of (name, transformer, column(s)) tuples specifying the
transformer objects to be applied to subsets of the data.</p>
<dl class="last docutils">
<dt>name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Like in Pipeline and FeatureUnion, this allows the transformer and
its parameters to be set using <code class="docutils literal notranslate"><span class="pre">set_params</span></code> and searched in grid
search.</p>
</dd>
<dt>transformer <span class="classifier-delimiter">:</span> <span class="classifier">estimator or {‘passthrough’, ‘drop’}</span></dt>
<dd><p class="first last">Estimator must support <cite>fit</cite> and <cite>transform</cite>. Special-cased
strings ‘drop’ and ‘passthrough’ are accepted as well, to
indicate to drop the columns or to pass them through untransformed,
respectively.</p>
</dd>
<dt>column(s) <span class="classifier-delimiter">:</span> <span class="classifier">string or int, array-like of string or int, slice, boolean mask array or callable</span></dt>
<dd><p class="first last">Indexes the data on its second axis. Integers are interpreted as
positional columns, while strings can reference DataFrame columns
by name.  A scalar string or int should be used where
<code class="docutils literal notranslate"><span class="pre">transformer</span></code> expects X to be a 1d array-like (vector),
otherwise a 2d array will be passed to the transformer.
A callable is passed the input data <cite>X</cite> and can return any of the
above.</p>
</dd>
</dl>
</dd>
<dt><strong>remainder</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘drop’, ‘passthrough’} or estimator, default ‘drop’</span></dt>
<dd><p class="first last">By default, only the specified columns in <cite>transformers</cite> are
transformed and combined in the output, and the non-specified
columns are dropped. (default of <code class="docutils literal notranslate"><span class="pre">'drop'</span></code>).
By specifying <code class="docutils literal notranslate"><span class="pre">remainder='passthrough'</span></code>, all remaining columns that
were not specified in <cite>transformers</cite> will be automatically passed
through. This subset of columns is concatenated with the output of
the transformers.
By setting <code class="docutils literal notranslate"><span class="pre">remainder</span></code> to be an estimator, the remaining
non-specified columns will use the <code class="docutils literal notranslate"><span class="pre">remainder</span></code> estimator. The
estimator must support <cite>fit</cite> and <cite>transform</cite>.</p>
</dd>
<dt><strong>sparse_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, default = 0.3</span></dt>
<dd><p class="first last">If the transformed output consists of a mix of sparse and dense data,
it will be stacked as a sparse matrix if the density is lower than this
value. Use <code class="docutils literal notranslate"><span class="pre">sparse_threshold=0</span></code> to always return dense.
When the transformed output consists of all sparse or all dense data,
the stacked result will be sparse or dense, respectively, and this
keyword will be ignored.</p>
</dd>
<dt><strong>n_jobs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional (default=None)</span></dt>
<dd><p class="first last">Number of jobs to run in parallel.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means 1 unless in a <code class="xref py py-obj docutils literal notranslate"><span class="pre">joblib.parallel_backend</span></code> context.
<code class="docutils literal notranslate"><span class="pre">-1</span></code> means using all processors. See <a class="reference external" href="https://scikit-learn.org/stable/glossary.html#term-n_jobs" title="(in scikit-learn v0.24)"><span class="xref std std-term">Glossary</span></a>
for more details.</p>
</dd>
<dt><strong>transformer_weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd><p class="first last">Multiplicative weights for features per transformer. The output of the
transformer is multiplied by these weights. Keys are transformer names,
values the weights.</p>
</dd>
<dt><strong>preserve_dataframe</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, (default=True)</span></dt>
<dd><p class="first">Whether to preserve preserve pandas DataFrames when concatenating
the results.</p>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The default behavior of keeping DataFrames differs from
scikit-learn’s current behavior. Set <code class="docutils literal notranslate"><span class="pre">preserve_dataframe=False</span></code>
if you need to ensure that the output matches scikit-learn’s
ColumnTransformer.</p>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transformers_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The collection of fitted transformers as tuples of
(name, fitted_transformer, column). <cite>fitted_transformer</cite> can be an
estimator, ‘drop’, or ‘passthrough’. If there are remaining columns,
the final element is a tuple of the form:
(‘remainder’, transformer, remaining_columns) corresponding to the
<code class="docutils literal notranslate"><span class="pre">remainder</span></code> parameter. If there are remaining columns, then
<code class="docutils literal notranslate"><span class="pre">len(transformers_)==len(transformers)+1</span></code>, otherwise
<code class="docutils literal notranslate"><span class="pre">len(transformers_)==len(transformers)</span></code>.</p>
</dd>
<dt><a class="reference internal" href="generted/dask_ml.compose.ColumnTransformer.html#dask_ml.compose.ColumnTransformer.named_transformers_" title="dask_ml.compose.ColumnTransformer.named_transformers_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_transformers_</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">Bunch object, a dictionary with attribute access</span></dt>
<dd><p class="first last">Access the fitted transformer by name.</p>
</dd>
<dt><strong>sparse_output_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">Boolean flag indicating whether the output of <code class="docutils literal notranslate"><span class="pre">transform</span></code> is a
sparse matrix or a dense numpy array, which depends on the output
of the individual transformers and the <cite>sparse_threshold</cite> keyword.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="generted/dask_ml.compose.make_column_transformer.html#dask_ml.compose.make_column_transformer" title="dask_ml.compose.make_column_transformer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask_ml.compose.make_column_transformer</span></code></a></dt>
<dd>convenience function for combining the outputs of multiple transformer objects applied to column subsets of the original feature space.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The order of the columns in the transformed feature matrix follows the
order of how the columns are specified in the <cite>transformers</cite> list.
Columns of the original feature matrix that are not specified are
dropped from the resulting transformed feature matrix, unless specified
in the <cite>passthrough</cite> keyword. Those columns specified with <cite>passthrough</cite>
are added at the right to the output of the transformers.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask_ml.compose</span> <span class="kn">import</span> <span class="n">ColumnTransformer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">Normalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span> <span class="o">=</span> <span class="n">ColumnTransformer</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[(</span><span class="s2">&quot;norm1&quot;</span><span class="p">,</span> <span class="n">Normalizer</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
<span class="gp">... </span>     <span class="p">(</span><span class="s2">&quot;norm2&quot;</span><span class="p">,</span> <span class="n">Normalizer</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Normalizer scales each row of X to unit norm. A separate scaling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># is applied for the two first and two last elements of each</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># row independently.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>    <span class="c1"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">array([[0. , 1. , 0.5, 0.5],</span>
<span class="go">       [0.5, 0.5, 0. , 1. ]])</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generted/dask_ml.compose.ColumnTransformer.html#dask_ml.compose.ColumnTransformer.fit" title="dask_ml.compose.ColumnTransformer.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Fit all transformers using X.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generted/dask_ml.compose.ColumnTransformer.html#dask_ml.compose.ColumnTransformer.fit_transform" title="dask_ml.compose.ColumnTransformer.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit all transformers, transform the data and concatenate results.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generted/dask_ml.compose.ColumnTransformer.html#dask_ml.compose.ColumnTransformer.get_feature_names" title="dask_ml.compose.ColumnTransformer.get_feature_names"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_feature_names</span></code></a>()</td>
<td>Get feature names from all transformers.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generted/dask_ml.compose.ColumnTransformer.html#dask_ml.compose.ColumnTransformer.get_params" title="dask_ml.compose.ColumnTransformer.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generted/dask_ml.compose.ColumnTransformer.html#dask_ml.compose.ColumnTransformer.set_params" title="dask_ml.compose.ColumnTransformer.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**kwargs)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generted/dask_ml.compose.ColumnTransformer.html#dask_ml.compose.ColumnTransformer.transform" title="dask_ml.compose.ColumnTransformer.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X)</td>
<td>Transform X separately by each transformer, concatenate results.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.compose.ColumnTransformer.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.compose.ColumnTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit all transformers using X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, dataframe} of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Input data, of which specified subsets are used to fit the
transformers.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,…), default=None</span></dt>
<dd><p class="first last">Targets for supervised learning.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ColumnTransformer</span></dt>
<dd><p class="first last">This estimator</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.compose.ColumnTransformer.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.compose.ColumnTransformer.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit all transformers, transform the data and concatenate results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, dataframe} of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Input data, of which specified subsets are used to fit the
transformers.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,), default=None</span></dt>
<dd><p class="first last">Targets for supervised learning.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix} of                 shape (n_samples, sum_n_components)</span></dt>
<dd><p class="first last">hstack of results of transformers. sum_n_components is the
sum of n_components (output dimension) over transformers. If
any result is a sparse matrix, everything will be converted to
sparse matrices.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.compose.ColumnTransformer.get_feature_names">
<code class="descname">get_feature_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.compose.ColumnTransformer.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Get feature names from all transformers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>feature_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of strings</span></dt>
<dd><p class="first last">Names of the features produced by transform.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.compose.ColumnTransformer.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.compose.ColumnTransformer.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<p>Returns the parameters given in the constructor as well as the
estimators contained within the <cite>transformers</cite> of the
<cite>ColumnTransformer</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dask_ml.compose.ColumnTransformer.named_transformers_">
<code class="descname">named_transformers_</code><a class="headerlink" href="#dask_ml.compose.ColumnTransformer.named_transformers_" title="Permalink to this definition">¶</a></dt>
<dd><p>Access the fitted transformer by name.</p>
<p>Read-only attribute to access any transformer by given name.
Keys are transformer names and values are the fitted transformer
objects.</p>
</dd></dl>

<dl class="method">
<dt id="dask_ml.compose.ColumnTransformer.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.compose.ColumnTransformer.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>Valid parameter keys can be listed with <code class="docutils literal notranslate"><span class="pre">get_params()</span></code>. Note that you
can directly set the parameters of the estimators contained in
<cite>transformers</cite> of <cite>ColumnTransformer</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>self</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.compose.ColumnTransformer.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.compose.ColumnTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform X separately by each transformer, concatenate results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, dataframe} of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The data to be transformed by subset.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix} of                 shape (n_samples, sum_n_components)</span></dt>
<dd><p class="first last">hstack of results of transformers. sum_n_components is the
sum of n_components (output dimension) over transformers. If
any result is a sparse matrix, everything will be converted to
sparse matrices.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="dask_ml.compose.make_column_transformer">
<code class="descclassname">dask_ml.compose.</code><code class="descname">make_column_transformer</code><span class="sig-paren">(</span><em>*transformers</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.compose.make_column_transformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a ColumnTransformer from the given transformers.</p>
<p>This is a shorthand for the ColumnTransformer constructor; it does not
require, and does not permit, naming the transformers. Instead, they will
be given names automatically based on their types. It also does not allow
weighting with <code class="docutils literal notranslate"><span class="pre">transformer_weights</span></code>.</p>
<p>Read more in the <a class="reference external" href="https://scikit-learn.org/stable/modules/compose.html#make-column-transformer" title="(in scikit-learn v0.24)"><span class="xref std std-ref">User Guide</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>*transformers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuples</span></dt>
<dd><p class="first">Tuples of the form (transformer, columns) specifying the
transformer objects to be applied to subsets of the data.</p>
<dl class="last docutils">
<dt>transformer <span class="classifier-delimiter">:</span> <span class="classifier">{‘drop’, ‘passthrough’} or estimator</span></dt>
<dd><p class="first last">Estimator must support <a class="reference external" href="https://scikit-learn.org/stable/glossary.html#term-fit" title="(in scikit-learn v0.24)"><span class="xref std std-term">fit</span></a> and <a class="reference external" href="https://scikit-learn.org/stable/glossary.html#term-transform" title="(in scikit-learn v0.24)"><span class="xref std std-term">transform</span></a>.
Special-cased strings ‘drop’ and ‘passthrough’ are accepted as
well, to indicate to drop the columns or to pass them through
untransformed, respectively.</p>
</dd>
<dt>columns <span class="classifier-delimiter">:</span> <span class="classifier">str,  array-like of str, int, array-like of int, slice,                 array-like of bool or callable</span></dt>
<dd><p class="first last">Indexes the data on its second axis. Integers are interpreted as
positional columns, while strings can reference DataFrame columns
by name. A scalar string or int should be used where
<code class="docutils literal notranslate"><span class="pre">transformer</span></code> expects X to be a 1d array-like (vector),
otherwise a 2d array will be passed to the transformer.
A callable is passed the input data <cite>X</cite> and can return any of the
above. To select multiple columns by name or dtype, you can use
<code class="xref py py-obj docutils literal notranslate"><span class="pre">make_column_selector</span></code>.</p>
</dd>
</dl>
</dd>
<dt><strong>remainder</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘drop’, ‘passthrough’} or estimator, default=’drop’</span></dt>
<dd><p class="first last">By default, only the specified columns in <cite>transformers</cite> are
transformed and combined in the output, and the non-specified
columns are dropped. (default of <code class="docutils literal notranslate"><span class="pre">'drop'</span></code>).
By specifying <code class="docutils literal notranslate"><span class="pre">remainder='passthrough'</span></code>, all remaining columns that
were not specified in <cite>transformers</cite> will be automatically passed
through. This subset of columns is concatenated with the output of
the transformers.
By setting <code class="docutils literal notranslate"><span class="pre">remainder</span></code> to be an estimator, the remaining
non-specified columns will use the <code class="docutils literal notranslate"><span class="pre">remainder</span></code> estimator. The
estimator must support <a class="reference external" href="https://scikit-learn.org/stable/glossary.html#term-fit" title="(in scikit-learn v0.24)"><span class="xref std std-term">fit</span></a> and <a class="reference external" href="https://scikit-learn.org/stable/glossary.html#term-transform" title="(in scikit-learn v0.24)"><span class="xref std std-term">transform</span></a>.</p>
</dd>
<dt><strong>sparse_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, default=0.3</span></dt>
<dd><p class="first last">If the transformed output consists of a mix of sparse and dense data,
it will be stacked as a sparse matrix if the density is lower than this
value. Use <code class="docutils literal notranslate"><span class="pre">sparse_threshold=0</span></code> to always return dense.
When the transformed output consists of all sparse or all dense data,
the stacked result will be sparse or dense, respectively, and this
keyword will be ignored.</p>
</dd>
<dt><strong>n_jobs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default=None</span></dt>
<dd><p class="first last">Number of jobs to run in parallel.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means 1 unless in a <code class="xref py py-obj docutils literal notranslate"><span class="pre">joblib.parallel_backend</span></code> context.
<code class="docutils literal notranslate"><span class="pre">-1</span></code> means using all processors. See <a class="reference external" href="https://scikit-learn.org/stable/glossary.html#term-n_jobs" title="(in scikit-learn v0.24)"><span class="xref std std-term">Glossary</span></a>
for more details.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=False</span></dt>
<dd><p class="first last">If True, the time elapsed while fitting each transformer will be
printed as it is completed.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ct</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ColumnTransformer</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="generted/dask_ml.compose.ColumnTransformer.html#dask_ml.compose.ColumnTransformer" title="dask_ml.compose.ColumnTransformer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ColumnTransformer</span></code></a></dt>
<dd>Class that allows combining the outputs of multiple transformer objects used on column subsets of the data into a single feature space.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span><span class="p">,</span> <span class="n">OneHotEncoder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.compose</span> <span class="kn">import</span> <span class="n">make_column_transformer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">make_column_transformer</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">(</span><span class="n">StandardScaler</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;numerical_column&#39;</span><span class="p">]),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="n">OneHotEncoder</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;categorical_column&#39;</span><span class="p">]))</span>
<span class="go">ColumnTransformer(transformers=[(&#39;standardscaler&#39;, StandardScaler(...),</span>
<span class="go">                                 [&#39;numerical_column&#39;]),</span>
<span class="go">                                (&#39;onehotencoder&#39;, OneHotEncoder(...),</span>
<span class="go">                                 [&#39;categorical_column&#39;])])</span>
</pre></div>
</div>
</dd></dl>

<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generted/dask_ml.compose.ColumnTransformer.html#dask_ml.compose.ColumnTransformer" title="dask_ml.compose.ColumnTransformer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compose.ColumnTransformer</span></code></a>(transformers[,&nbsp;…])</td>
<td>Applies transformers to columns of an array or pandas DataFrame.</td>
</tr>
</tbody>
</table>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generted/dask_ml.compose.make_column_transformer.html#dask_ml.compose.make_column_transformer" title="dask_ml.compose.make_column_transformer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compose.make_column_transformer</span></code></a>(…)</td>
<td>Construct a ColumnTransformer from the given transformers.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dask_ml.impute">
<span id="dask-ml-impute-imputing-missing-data"></span><h2><a class="reference internal" href="#module-dask_ml.impute" title="dask_ml.impute"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.impute</span></code></a>: Imputing Missing Data<a class="headerlink" href="#module-dask_ml.impute" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dask_ml.impute.SimpleImputer">
<em class="property">class </em><code class="descclassname">dask_ml.impute.</code><code class="descname">SimpleImputer</code><span class="sig-paren">(</span><em>*</em>, <em>missing_values=nan</em>, <em>strategy='mean'</em>, <em>fill_value=None</em>, <em>verbose=0</em>, <em>copy=True</em>, <em>add_indicator=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.impute.SimpleImputer" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.impute.SimpleImputer.html#dask_ml.impute.SimpleImputer.fit" title="dask_ml.impute.SimpleImputer.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Fit the imputer on X.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.impute.SimpleImputer.html#dask_ml.impute.SimpleImputer.fit_transform" title="dask_ml.impute.SimpleImputer.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.impute.SimpleImputer.html#dask_ml.impute.SimpleImputer.get_params" title="dask_ml.impute.SimpleImputer.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.impute.SimpleImputer.html#dask_ml.impute.SimpleImputer.inverse_transform" title="dask_ml.impute.SimpleImputer.inverse_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_transform</span></code></a>(X)</td>
<td>Convert the data back to the original representation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.impute.SimpleImputer.html#dask_ml.impute.SimpleImputer.set_params" title="dask_ml.impute.SimpleImputer.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.impute.SimpleImputer.html#dask_ml.impute.SimpleImputer.transform" title="dask_ml.impute.SimpleImputer.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X)</td>
<td>Impute all missing values in X.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dask_ml.impute.SimpleImputer.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.impute.SimpleImputer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the imputer on X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix}, shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Input data, where <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> is the number of samples and
<code class="docutils literal notranslate"><span class="pre">n_features</span></code> is the number of features.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">SimpleImputer</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.impute.SimpleImputer.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.impute.SimpleImputer.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to <cite>X</cite> and <cite>y</cite> with optional parameters <cite>fit_params</cite>
and returns a transformed version of <cite>X</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">Input samples.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None</span></dt>
<dd><p class="first last">Target values (None for unsupervised transformations).</p>
</dd>
<dt><strong>**fit_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Additional fit parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray array of shape (n_samples, n_features_new)</span></dt>
<dd><p class="first last">Transformed array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.impute.SimpleImputer.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.impute.SimpleImputer.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default=True</span></dt>
<dd><p class="first last">If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameter names mapped to their values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.impute.SimpleImputer.inverse_transform">
<code class="descname">inverse_transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.impute.SimpleImputer.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the data back to the original representation.</p>
<p>Inverts the <cite>transform</cite> operation performed on an array.
This operation can only be performed after <a class="reference internal" href="generated/dask_ml.impute.SimpleImputer.html#dask_ml.impute.SimpleImputer" title="dask_ml.impute.SimpleImputer"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleImputer</span></code></a> is
instantiated with <cite>add_indicator=True</cite>.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">inverse_transform</span></code> can only invert the transform in
features that have binary indicators for missing values. If a feature
has no missing values at <code class="docutils literal notranslate"><span class="pre">fit</span></code> time, the feature won’t have a binary
indicator, and the imputation done at <code class="docutils literal notranslate"><span class="pre">transform</span></code> time won’t be
inverted.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.24.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of shape                 (n_samples, n_features + n_features_missing_indicator)</span></dt>
<dd><p class="first last">The imputed data to be reverted to original data. It has to be
an augmented array of imputed data and the missing indicator mask.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_original</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The original X with missing values as it was prior
to imputation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.impute.SimpleImputer.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.impute.SimpleImputer.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="(in scikit-learn v0.24)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>). The latter have
parameters of the form <code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s
possible to update each component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>**params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Estimator parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">estimator instance</span></dt>
<dd><p class="first last">Estimator instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dask_ml.impute.SimpleImputer.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.impute.SimpleImputer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Impute all missing values in X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{array-like, sparse matrix}, shape (n_samples, n_features)</span></dt>
<dd><p class="first last">The input data to complete.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.impute.SimpleImputer.html#dask_ml.impute.SimpleImputer" title="dask_ml.impute.SimpleImputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">impute.SimpleImputer</span></code></a>(*[,&nbsp;missing_values,&nbsp;…])</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dask-ml-metrics-metrics">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.metrics</span></code>: Metrics<a class="headerlink" href="#dask-ml-metrics-metrics" title="Permalink to this headline">¶</a></h2>
<p>Score functions, performance metrics, and pairwise distance computations.</p>
<div class="section" id="regression-metrics">
<h3>Regression Metrics<a class="headerlink" href="#regression-metrics" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.metrics.mean_absolute_error.html#dask_ml.metrics.mean_absolute_error" title="dask_ml.metrics.mean_absolute_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">metrics.mean_absolute_error</span></code></a>(y_true,&nbsp;y_pred,&nbsp;…)</td>
<td>Mean absolute error regression loss.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.metrics.mean_squared_error.html#dask_ml.metrics.mean_squared_error" title="dask_ml.metrics.mean_squared_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">metrics.mean_squared_error</span></code></a>(y_true,&nbsp;y_pred,&nbsp;…)</td>
<td>Mean squared error regression loss.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.metrics.mean_squared_log_error.html#dask_ml.metrics.mean_squared_log_error" title="dask_ml.metrics.mean_squared_log_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">metrics.mean_squared_log_error</span></code></a>(y_true,&nbsp;…)</td>
<td>Mean squared logarithmic error regression loss.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.metrics.r2_score.html#dask_ml.metrics.r2_score" title="dask_ml.metrics.r2_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">metrics.r2_score</span></code></a>(y_true,&nbsp;y_pred,&nbsp;…)</td>
<td>R^2 (coefficient of determination) regression score function.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="classification-metrics">
<h3>Classification Metrics<a class="headerlink" href="#classification-metrics" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.metrics.accuracy_score.html#dask_ml.metrics.accuracy_score" title="dask_ml.metrics.accuracy_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">metrics.accuracy_score</span></code></a>(y_true,&nbsp;y_pred,&nbsp;…)</td>
<td>Accuracy classification score.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.metrics.log_loss.html#dask_ml.metrics.log_loss" title="dask_ml.metrics.log_loss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">metrics.log_loss</span></code></a>(y_true,&nbsp;y_pred[,&nbsp;eps,&nbsp;…])</td>
<td>Log loss, aka logistic loss or cross-entropy loss.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="module-dask_ml.xgboost">
<span id="dask-ml-xgboost-xgboost"></span><h2><a class="reference internal" href="#module-dask_ml.xgboost" title="dask_ml.xgboost"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.xgboost</span></code></a>: XGBoost<a class="headerlink" href="#module-dask_ml.xgboost" title="Permalink to this headline">¶</a></h2>
<p>Train an XGBoost model on dask arrays or dataframes.</p>
<p>This may be used for training an XGBoost model on a cluster. XGBoost
will be setup in distributed mode alongside your existing
<code class="docutils literal notranslate"><span class="pre">dask.distributed</span></code> cluster.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.xgboost.XGBClassifier.html#dask_ml.xgboost.XGBClassifier" title="dask_ml.xgboost.XGBClassifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">XGBClassifier</span></code></a>(*[,&nbsp;objective,&nbsp;use_label_encoder])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.xgboost.XGBRegressor.html#dask_ml.xgboost.XGBRegressor" title="dask_ml.xgboost.XGBRegressor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">XGBRegressor</span></code></a>(*[,&nbsp;objective])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.xgboost.train.html#dask_ml.xgboost.train" title="dask_ml.xgboost.train"><code class="xref py py-obj docutils literal notranslate"><span class="pre">train</span></code></a>(client,&nbsp;params,&nbsp;data,&nbsp;labels[,&nbsp;…])</td>
<td>Train an XGBoost model on a Dask Cluster</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.xgboost.predict.html#dask_ml.xgboost.predict" title="dask_ml.xgboost.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(client,&nbsp;model,&nbsp;data)</td>
<td>Distributed prediction with XGBoost</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dask-ml-datasets-datasets">
<h2><a class="reference internal" href="#module-dask_ml.datasets" title="dask_ml.datasets"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dask_ml.datasets</span></code></a>: Datasets<a class="headerlink" href="#dask-ml-datasets-datasets" title="Permalink to this headline">¶</a></h2>
<p>dask-ml provides some utilities for generating toy datasets.</p>
<span class="target" id="module-dask_ml.datasets"></span><dl class="function">
<dt id="dask_ml.datasets.make_blobs">
<code class="descclassname">dask_ml.datasets.</code><code class="descname">make_blobs</code><span class="sig-paren">(</span><em>n_samples=100</em>, <em>n_features=2</em>, <em>centers=None</em>, <em>cluster_std=1.0</em>, <em>center_box=(-10.0</em>, <em>10.0)</em>, <em>shuffle=True</em>, <em>random_state=None</em>, <em>chunks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.datasets.make_blobs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate isotropic Gaussian blobs for clustering.</p>
<p>This can be used to generate very large Dask arrays on a cluster of
machines. When using Dask in distributed mode, the client machine
only needs to allocate a single block’s worth of data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n_samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or array-like, optional (default=100)</span></dt>
<dd><p class="first last">If int, it is the total number of points equally divided among
clusters.
If array-like, each element of the sequence indicates
the number of samples per cluster.</p>
</dd>
<dt><strong>n_features</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (default=2)</span></dt>
<dd><p class="first last">The number of features for each sample.</p>
</dd>
<dt><strong>centers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or array of shape [n_centers, n_features], optional</span></dt>
<dd><p class="first last">(default=None)
The number of centers to generate, or the fixed center locations.
If n_samples is an int and centers is None, 3 centers are generated.
If n_samples is array-like, centers must be
either None or an array of length equal to the length of n_samples.</p>
</dd>
<dt><strong>cluster_std</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or sequence of floats, optional (default=1.0)</span></dt>
<dd><p class="first last">The standard deviation of the clusters.</p>
</dd>
<dt><strong>center_box</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pair of floats (min, max), optional (default=(-10.0, 10.0))</span></dt>
<dd><p class="first last">The bounding box for each cluster center when centers are
generated at random.</p>
</dd>
<dt><strong>shuffle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional (default=True)</span></dt>
<dd><p class="first last">Shuffle the samples.</p>
</dd>
<dt><strong>random_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, RandomState instance or None (default)</span></dt>
<dd><p class="first last">Determines random number generation for dataset creation. Pass an int
for reproducible output across multiple function calls.
See <a class="reference external" href="https://scikit-learn.org/stable/glossary.html#term-random_state" title="(in scikit-learn v0.24)"><span class="xref std std-term">Glossary</span></a>.</p>
</dd>
<dt><strong>chunks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, tuple</span></dt>
<dd><p class="first">How to chunk the array. Must be one of the following forms:
-   A blocksize like 1000.
-   A blockshape like (1000, 1000).
-   Explicit sizes of all blocks along all dimensions like</p>
<blockquote class="last">
<div><p>((1000, 1000, 500), (400, 400)).</p>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of shape [n_samples, n_features]</span></dt>
<dd><p class="first last">The generated samples.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of shape [n_samples]</span></dt>
<dd><p class="first last">The integer labels for cluster membership of each sample.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="generated/dask_ml.datasets.make_classification.html#dask_ml.datasets.make_classification" title="dask_ml.datasets.make_classification"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_classification</span></code></a></dt>
<dd>a more intricate variant</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask_ml.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>
<span class="go">dask.array&lt;..., shape=(100000, 2), dtype=float64, chunksize=(10000, 2)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">dask.array&lt;concatenate, shape=(100000,), dtype=int64, chunksize=(10000,)&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask_ml.datasets.make_classification_df">
<code class="descclassname">dask_ml.datasets.</code><code class="descname">make_classification_df</code><span class="sig-paren">(</span><em>n_samples=10000</em>, <em>response_rate=0.5</em>, <em>predictability=0.1</em>, <em>random_state=None</em>, <em>chunks=None</em>, <em>dates=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.datasets.make_classification_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses the make_classification function to create a dask
dataframe for testing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n_samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default is 10000</span></dt>
<dd><p class="first last">number of observations to be generated</p>
</dd>
<dt><strong>response_rate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float between 0.0 and 0.5, default is 0.5</span></dt>
<dd><p class="first last">percentage of sample to be response records max is 0.5</p>
</dd>
<dt><strong>predictability</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float between 0.0 and 1.0, default is 0.1</span></dt>
<dd><p class="first last">how hard is the response to predict (1.0 being easiest)</p>
</dd>
<dt><strong>random_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default is None</span></dt>
<dd><p class="first last">seed for reproducibility purposes</p>
</dd>
<dt><strong>chunks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">How to chunk the array. Must be one of the following forms:
-   A blocksize like 1000.</p>
</dd>
<dt><strong>dates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple, optional, default is None</span></dt>
<dd><p class="first last">tuple of start and end date objects to use for generating
random dates in the date column</p>
</dd>
<dt><strong>**kwargs</strong></dt>
<dd><p class="first last">Other keyword arguments to pass to <cite>sklearn.datasets.make_classification</cite></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dask DataFrame of shape [n_samples, n_features] or</span></dt>
<dd><p class="first last">[n_samples, n_features + 1] when dates specified
The input samples.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dask Series of shape [n_samples] or [n_samples, n_targets]</span></dt>
<dd><p class="first last">The output values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="dask_ml.datasets.make_counts">
<code class="descclassname">dask_ml.datasets.</code><code class="descname">make_counts</code><span class="sig-paren">(</span><em>n_samples=1000</em>, <em>n_features=100</em>, <em>n_informative=2</em>, <em>scale=1.0</em>, <em>chunks=100</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.datasets.make_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a dummy dataset for modeling count data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n_samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">number of rows in the output array</p>
</dd>
<dt><strong>n_features</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">number of columns (features) in the output array</p>
</dd>
<dt><strong>n_informative</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">number of features that are correlated with the outcome</p>
</dd>
<dt><strong>scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Scale the true coefficient array by this</p>
</dd>
<dt><strong>chunks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of rows per dask array block.</p>
</dd>
<dt><strong>random_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, RandomState instance or None (default)</span></dt>
<dd><p class="first last">Determines random number generation for dataset creation. Pass an int
for reproducible output across multiple function calls.
See <a class="reference external" href="https://scikit-learn.org/stable/glossary.html#term-random_state" title="(in scikit-learn v0.24)"><span class="xref std std-term">Glossary</span></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dask.array, size <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_features)</span></code></span></dt>
<dd></dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dask.array, size <code class="docutils literal notranslate"><span class="pre">(n_samples,)</span></code></span></dt>
<dd><p class="first last">array of non-negative integer-valued data</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_counts</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask_ml.datasets.make_regression">
<code class="descclassname">dask_ml.datasets.</code><code class="descname">make_regression</code><span class="sig-paren">(</span><em>n_samples=100</em>, <em>n_features=100</em>, <em>n_informative=10</em>, <em>n_targets=1</em>, <em>bias=0.0</em>, <em>effective_rank=None</em>, <em>tail_strength=0.5</em>, <em>noise=0.0</em>, <em>shuffle=True</em>, <em>coef=False</em>, <em>random_state=None</em>, <em>chunks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask_ml.datasets.make_regression" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a random regression problem.</p>
<p>The input set can either be well conditioned (by default) or have a low
rank-fat tail singular profile. See
<a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_low_rank_matrix.html#sklearn.datasets.make_low_rank_matrix" title="(in scikit-learn v0.24)"><code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.datasets.make_low_rank_matrix()</span></code></a> for more details.</p>
<p>This can be used to generate very large Dask arrays on a cluster of
machines. When using Dask in distributed mode, the client machine
only needs to allocate a single block’s worth of data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n_samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (default=100)</span></dt>
<dd><p class="first last">The number of samples.</p>
</dd>
<dt><strong>n_features</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (default=100)</span></dt>
<dd><p class="first last">The number of features.</p>
</dd>
<dt><strong>n_informative</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (default=10)</span></dt>
<dd><p class="first last">The number of informative features, i.e., the number of features used
to build the linear model used to generate the output.</p>
</dd>
<dt><strong>n_targets</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (default=1)</span></dt>
<dd><p class="first last">The number of regression targets, i.e., the dimension of the y output
vector associated with a sample. By default, the output is a scalar.</p>
</dd>
<dt><strong>bias</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (default=0.0)</span></dt>
<dd><p class="first last">The bias term in the underlying linear model.</p>
</dd>
<dt><strong>effective_rank</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional (default=None)</span></dt>
<dd><dl class="first last docutils">
<dt>if not None:</dt>
<dd><p class="first last">The approximate number of singular vectors required to explain most
of the input data by linear combinations. Using this kind of
singular spectrum in the input allows the generator to reproduce
the correlations often observed in practice.</p>
</dd>
<dt>if None:</dt>
<dd><p class="first last">The input set is well conditioned, centered and gaussian with
unit variance.</p>
</dd>
</dl>
</dd>
<dt><strong>tail_strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float between 0.0 and 1.0, optional (default=0.5)</span></dt>
<dd><p class="first last">The relative importance of the fat noisy tail of the singular values
profile if <cite>effective_rank</cite> is not None.</p>
</dd>
<dt><strong>noise</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (default=0.0)</span></dt>
<dd><p class="first last">The standard deviation of the gaussian noise applied to the output.</p>
</dd>
<dt><strong>shuffle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional (default=True)</span></dt>
<dd><p class="first last">Shuffle the samples and the features.</p>
</dd>
<dt><strong>coef</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional (default=False)</span></dt>
<dd><p class="first last">If True, the coefficients of the underlying linear model are returned.</p>
</dd>
<dt><strong>random_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, RandomState instance or None (default)</span></dt>
<dd><p class="first last">Determines random number generation for dataset creation. Pass an int
for reproducible output across multiple function calls.
See <a class="reference external" href="https://scikit-learn.org/stable/glossary.html#term-random_state" title="(in scikit-learn v0.24)"><span class="xref std std-term">Glossary</span></a>.</p>
</dd>
<dt><strong>chunks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, tuple</span></dt>
<dd><p class="first">How to chunk the array. Must be one of the following forms:
-   A blocksize like 1000.
-   A blockshape like (1000, 1000).
-   Explicit sizes of all blocks along all dimensions like</p>
<blockquote class="last">
<div><p>((1000, 1000, 500), (400, 400)).</p>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dask array of shape [n_samples, n_features]</span></dt>
<dd><p class="first last">The input samples.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dask array of shape [n_samples] or [n_samples, n_targets]</span></dt>
<dd><p class="first last">The output values.</p>
</dd>
<dt><strong>coef</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of shape [n_features] or [n_features, n_targets], optional</span></dt>
<dd><p class="first last">The coefficient of the underlying linear model. It is returned only if
coef is True.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.datasets.make_counts.html#dask_ml.datasets.make_counts" title="dask_ml.datasets.make_counts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_counts</span></code></a>([n_samples,&nbsp;n_features,&nbsp;…])</td>
<td>Generate a dummy dataset for modeling count data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.datasets.make_blobs.html#dask_ml.datasets.make_blobs" title="dask_ml.datasets.make_blobs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_blobs</span></code></a>([n_samples,&nbsp;n_features,&nbsp;centers,&nbsp;…])</td>
<td>Generate isotropic Gaussian blobs for clustering.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.datasets.make_regression.html#dask_ml.datasets.make_regression" title="dask_ml.datasets.make_regression"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_regression</span></code></a>([n_samples,&nbsp;n_features,&nbsp;…])</td>
<td>Generate a random regression problem.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/dask_ml.datasets.make_classification.html#dask_ml.datasets.make_classification" title="dask_ml.datasets.make_classification"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_classification</span></code></a>([n_samples,&nbsp;n_features,&nbsp;…])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/dask_ml.datasets.make_classification_df.html#dask_ml.datasets.make_classification_df" title="dask_ml.datasets.make_classification_df"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_classification_df</span></code></a>([n_samples,&nbsp;…])</td>
<td>Uses the make_classification function to create a dask dataframe for testing.</td>
</tr>
</tbody>
</table>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="generated/dask_ml.model_selection.train_test_split.html" class="btn btn-neutral float-right" title="dask_ml.model_selection.train_test_split" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="../clustering.html" class="btn btn-neutral float-left" title="Clustering" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2017, Dask developers.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>